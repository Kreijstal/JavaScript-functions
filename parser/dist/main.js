/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./interactive.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./interactive.js":
/*!************************!*\
  !*** ./interactive.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var lang=__webpack_require__(/*! ./lang.js */ \"./lang.js\");\nvar expressionFeatures=__webpack_require__(/*! ./lang.js */ \"./lang.js\")\nvar regexGrammar=__webpack_require__(/*! ./regex-rules.js */ \"./regex-rules.js\")\nvar parse=__webpack_require__(/*! ./parser.js */ \"./parser.js\")\n\nconsole.log('parse(expressionFeatures, regexGrammar, \"/hell\"+ \"o/\");')\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pbnRlcmFjdGl2ZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2ludGVyYWN0aXZlLmpzP2IwNGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGxhbmc9cmVxdWlyZSgnLi9sYW5nLmpzJyk7XG52YXIgZXhwcmVzc2lvbkZlYXR1cmVzPXJlcXVpcmUoJy4vbGFuZy5qcycpXG52YXIgcmVnZXhHcmFtbWFyPXJlcXVpcmUoJy4vcmVnZXgtcnVsZXMuanMnKVxudmFyIHBhcnNlPXJlcXVpcmUoJy4vcGFyc2VyLmpzJylcblxuY29uc29sZS5sb2coJ3BhcnNlKGV4cHJlc3Npb25GZWF0dXJlcywgcmVnZXhHcmFtbWFyLCBcIi9oZWxsXCIrIFwiby9cIik7JylcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./interactive.js\n");

/***/ }),

/***/ "./lang.js":
/*!*****************!*\
  !*** ./lang.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var parse=__webpack_require__(/*! ./parser-constants.js */ \"./parser-constants.js\")\n/*\nexpressionFeatures is basically an object that defines how the grammar object should be interpreted BY STEPS!\n*/\nvar expressionFeatures = {\n  array: function sequence(match) {\n    //check if child has errored, sequence ensures that everything should be matched, therefore error will bubble up, parse.THROW\n    if (match.childStep) {\n      if (match.childStep.fail) {\n        return [parse.THROW, \"Array Error: Sequence: didn't match completely. Children have errored. At index \" + match.indexOf]\n      }\n      //If children returned result, then\n      if (match.childStep.result) {\n        //if local result doesn't exist, create one\n        if (!match.result) { match.result = []; }\n        //push result\n        match.result.push(match.childStep.result);\n        //clear global result\n      }\n      if(match.childStep.indexOf!==match.indexOf){\n    \tmatch.indexOf=match.childStep.indexOf\n    }\n    }\n    //create iterator if not already created\n    match.iterator|=0;\n    //get next iteration\n    var val = match.context[match.iterator++];\n    //if iteration is not undefined parse.STEP_IN into next iteration\n    if (val !== undefined) {\n      return [parse.STEP_IN, val]\n    }\n    //otherwise parse.STEP_OUT\n    else {\n      return [parse.STEP_OUT];\n    }\n t},\n  string: function literalmatch(match, textToParse) {\n    //Note: I had to add comments because reading was truly a pain\n    //trim text to parse to be as long as string to match (from indexOf), let that. be str\n    var str = textToParse.substr(match.indexOf-(match.reverse?match.context.length:0), match.context.length),\n      //trim string to match, to be as long as str is (from match.indexOf-parseContext.indexOf), let that be str2\n      str2 = match.context.substr(match.indexOf - match.startIndexOf, str.length)\n    //str2 is needed in order to match partial matches when the text to parse is incomplete\n    //match.indexOf is local indexOf, this will be different from parseContext.indexOf (the expressionFeature indexOf) if parser has been halted before\n    //if str equals str2\n    if (str === str2) {\n      //match.indexOf (cursor) is moved the str (or str2) distance\n      match.indexOf += str.length*(match.reverse?-1:1);\n      //if string to match is longer than str then HALT (assume that text to parse is not complete)\n      if (match.context.length > str.length) {\n        if(match.isFinal())return [parse.THROW,\"String match: EOF Reached\"]\n        return [parse.HALT]\n      }\n      else {\n        //else parse.STEP_OUT\n        //no result because literal match is literal\n        match.result=str2;//result because debugging.\n        return [parse.STEP_OUT];\n      }\n    }\n    //else parse.THROW\n    else {\n      //debugger\n      return [parse.THROW, \"String Error: expected \\\"\" + match.context + \"\\\", found \\\"\" + str + \"\\\" at index:\" + match.indexOf]\n    }\n  },\n  meta: { restorable: [\"repetition\", \"or\"] },\n  object: {\n    repetition: function quantifier(match) {\n      //Repetitions can be greedy, lazy, possessive\n      //if match.matches doesn't exist create one\n      //match.matches is used to store the different matches that the repetition has caught.\n      if (!match.matches) {\n        match.matches = []\n      }\n            //if parse tree was restored\n      //then keep trying to match another option, if greedy take 1 less, if lazy take 1 more\n      if (match.restored) {\n        match.restored = false;\n        switch (match.context.quantifier) {\n          case \"greedy\":\n            //attempt to take 1 less unit, if there is less than from, repetition fails\n            if (match.matches.length > match.context.from) {\n              match.matches.pop();\n              //match.result.pop();\n              match.indexOf = match.matches[match.matches.length - 1]\n              return [parse.STEP_OUT]\n            }\n            else {\n              return [parse.THROW, \"Attempted to take 1 less unit in greedy pattern, in \" + match.indexOf + \" but doing so exceeded the defined bounds.\"]\n            }\n            break;\n          case \"lazy\":\n            //attempt to take 1 more unit, if it fails, repetition fails\n            if (match.matches.length < match.context.to) {\n              match.lazypass = true;\n              //despite the pattern is lazy, it has failed so it must take the following step\n            }\n            else {\n              return [parse.THROW, \"Attempted to take 1 more unit in lazy pattern, in \" + match.indexOf + \" but doing so exceeded the defined bounds.\"]\n            }\n            break;\n        }\n      }\n      //if children returned result\n      else if (match.childStep) {\n        if (match.childStep.result) {\n          if (!match.result) {\n            match.result = [];\n          }\n          match.result.push(match.childStep.result);\n          match.matches.push(match.indexOf)\n        }\n        //Reasons for Repetition to end\n        //Repetition iteration threw error while trying to match next repetition item\n        //Repetition reached maximum number of items\n        if (match.childStep.fail || (match.matches.length === match.context.to)) { //could be restored, or could be group value was falsy\n          //Not bubbling errors up.\n          //if loop failed\n          //check if loop requirements match or if its lazy (if it's lazy that means that an attempt to match failed therefore pattern failed to match)\n          if ((match.context.quantifier !== \"lazy\") && (match.context.from <= match.matches.length && match.context.to >= match.matches.length)) {\n            //requirements seem to fit!\n            if(match.childStep.indexOf){\n              match.indexOf=match.childStep.indexOf\n            }\n            return [parse.STEP_OUT]\n          }\n          else { //requirements dont match\n            return [parse.THROW, \"Repetition ended at \" + match.indexOf + \" and either repetition exceeded bounds or failed matching a lazy pattern\"]\n          }\n        }\n      }\n      //if iterator is bigger than from and it is lazy but its not lazypassed, then\n      if ((match.matches.length > match.context.from) && (match.context.quantifier === \"lazy\") && (!match.lazypass)) {\n        if(match.childStep.indexOf){\n              match.indexOf=match.childStep.indexOf\n            }\n        return [parse.STEP_OUT]\n      }\n      match.lazypass = false;\n      return [parse.STEP_IN, match.context.child];\n    },\n    pointer: function(match, textToParse) {\n      if (match.childStep) {\n        if(match.childStep.fail)\n        return [parse.THROW,\"pointer failed\"]\n        match.result = match.childStep.result;\n        match.indexOf=match.childStep.indexOf\n        return [parse.STEP_OUT];\n      }\n      return [parse.STEP_IN, match.grammarKey(match.context.value)];\n    },\n    or: function alternation(match) { //well shit\n      //{type:\"or\",child:node[]}\n      if (match.childStep) {\n        if ((match.childStep.fail||match.restored) && (match.context.choices.length === match.iterator)) { //none of the choices work\n          return [parse.THROW, \"Alternation Error: None of the options in the alternation match. At index \" + match.indexOf]\n        }\n        else if ((!match.childStep.fail) && (match.iterator !== undefined)) {\n          if(match.childStep.result){\n          match.result = match.childStep.result;\n          }else{\n            match.result=match.iterator\n          }\n          match.indexOf=match.childStep.indexOf\n          return [parse.STEP_OUT];\n        }\n      }\n\n      match.iterator |=0;\n      var v = match.context.choices[match.iterator++];\n      if (v) {\n        return [parse.STEP_IN, v];\n      }\n      else {\n        return [parse.THROW, \"Alternation Error: None of the options in the alternation match. At index \" + match.indexOf]\n      }\n    },\n    //wildcard always matches a character\n    wildcard:function wildcard(match,text){\n//{type:\"wildcard\",value:[{from:5,to:7},\"a\",\"b\"],negative:false}\n      var t=text[match.indexOf-match.reverse],v\n      if(!t)    return [parse.THROW,\"Wildcard can't match empty string\"];\n      v=match.context.value.find(function(a){if(typeof a===\"object\"){return a.to>=t.charCodeAt()>=a.from}else{return a===t}})\n      v=match.context.negative?(v?false:t):v;\n      if(t===\"\"){\n        if(match.isFinal()){\n            return [parse.THROW,\"Wildcard can't match empty string\"];\n        }else{\n        return [parse.HALT];\n        }\n        \n      }\n      if (v) {\n        match.result=t;\n        //I SERIOUSLY CHANGING THE INDEXOF WHEN THE END OF \n        match.indexOf+=(match.reverse&&-1)|1;//match.reverse?-1:1\n        return [parse.STEP_OUT];\n      }\n      else {\n        return [parse.THROW, \"No value for wildcard\"]\n      }\n    },reverse:function(match){\n      match.reverse=!match.reverse\n      if(match.childStep){\n        if(match.childStep.fail) return [parse.THROW,match.childStep.failMsg]\n        match.result=match.childStep.result;\n        match.indexOf=match.childStep.indexOf\n        return [parse.STEP_OUT]\n      }\n      return [match.STEP_IN,match.context.value]\n    },variable:function(match){\n      var variables=match.variable();\n      if(match.childStep){\n        //I think most steps return a result and an indexOf to parent\n        if(match.childStep.fail) return [parse.THROW,match.childStep.failMsg]\n        match.result=variables[match.context.key]=match.childStep.result;\n        match.indexOf=match.childStep.indexOf\n        return [parse.STEP_OUT]\n      }\n      if(typeof match.context.value==\"undefined\"){\n        match.result=variables[match.context.key]\n        if(!match.result){\n          throw new ReferenceError(\"Value is undefined, and there is no variableKey \\\"\"+match.context.key+\"\\\" set.\")\n        }\n        return [parse.STEP_IN,match.result]\n      }else{\n        return [parse.STEP_IN,match.context.value]\n      }\n    },assertion:function(match,text){\n      //{type:\"assertion\",value:<pattern>,[negative:<boolean>]}\n       if(match.childStep){\n        if(match.childStep.fail!==match.negative) \n        return [parse.STEP_OUT]\n      }\n      //EOF assertions\n      if(match.context.value===\"\"){\n        if(match.indexOf===text.length){\n          return [parse.STEP_OUT]\n        }else{\n          return [parse.THROW,\"Assertion failed\"]\n        }\n      }\n      return [match.STEP_IN,match.context.value]\n      \n    },atomic:function(match){\n      match.atomicity=match.restore;\n     if(match.childStep){\n        if(match.childStep.fail) return [parse.THROW,match.childStep.failMsg]\n        match.result=match.childStep.result;\n        match.indexOf=match.childStep.indexOf\n        return [parse.STEP_OUT]\n      }\n      return [match.STEP_IN,match.context.value]\n    }\n  },\n  null: function() { return [parse.THROW, \"attempted to match null\"] }\n}\nmodule.exports = expressionFeatures;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9sYW5nLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbGFuZy5qcz9mNGQzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBwYXJzZT1yZXF1aXJlKCcuL3BhcnNlci1jb25zdGFudHMuanMnKVxuLypcbmV4cHJlc3Npb25GZWF0dXJlcyBpcyBiYXNpY2FsbHkgYW4gb2JqZWN0IHRoYXQgZGVmaW5lcyBob3cgdGhlIGdyYW1tYXIgb2JqZWN0IHNob3VsZCBiZSBpbnRlcnByZXRlZCBCWSBTVEVQUyFcbiovXG52YXIgZXhwcmVzc2lvbkZlYXR1cmVzID0ge1xuICBhcnJheTogZnVuY3Rpb24gc2VxdWVuY2UobWF0Y2gpIHtcbiAgICAvL2NoZWNrIGlmIGNoaWxkIGhhcyBlcnJvcmVkLCBzZXF1ZW5jZSBlbnN1cmVzIHRoYXQgZXZlcnl0aGluZyBzaG91bGQgYmUgbWF0Y2hlZCwgdGhlcmVmb3JlIGVycm9yIHdpbGwgYnViYmxlIHVwLCBwYXJzZS5USFJPV1xuICAgIGlmIChtYXRjaC5jaGlsZFN0ZXApIHtcbiAgICAgIGlmIChtYXRjaC5jaGlsZFN0ZXAuZmFpbCkge1xuICAgICAgICByZXR1cm4gW3BhcnNlLlRIUk9XLCBcIkFycmF5IEVycm9yOiBTZXF1ZW5jZTogZGlkbid0IG1hdGNoIGNvbXBsZXRlbHkuIENoaWxkcmVuIGhhdmUgZXJyb3JlZC4gQXQgaW5kZXggXCIgKyBtYXRjaC5pbmRleE9mXVxuICAgICAgfVxuICAgICAgLy9JZiBjaGlsZHJlbiByZXR1cm5lZCByZXN1bHQsIHRoZW5cbiAgICAgIGlmIChtYXRjaC5jaGlsZFN0ZXAucmVzdWx0KSB7XG4gICAgICAgIC8vaWYgbG9jYWwgcmVzdWx0IGRvZXNuJ3QgZXhpc3QsIGNyZWF0ZSBvbmVcbiAgICAgICAgaWYgKCFtYXRjaC5yZXN1bHQpIHsgbWF0Y2gucmVzdWx0ID0gW107IH1cbiAgICAgICAgLy9wdXNoIHJlc3VsdFxuICAgICAgICBtYXRjaC5yZXN1bHQucHVzaChtYXRjaC5jaGlsZFN0ZXAucmVzdWx0KTtcbiAgICAgICAgLy9jbGVhciBnbG9iYWwgcmVzdWx0XG4gICAgICB9XG4gICAgICBpZihtYXRjaC5jaGlsZFN0ZXAuaW5kZXhPZiE9PW1hdGNoLmluZGV4T2Ype1xuICAgIFx0bWF0Y2guaW5kZXhPZj1tYXRjaC5jaGlsZFN0ZXAuaW5kZXhPZlxuICAgIH1cbiAgICB9XG4gICAgLy9jcmVhdGUgaXRlcmF0b3IgaWYgbm90IGFscmVhZHkgY3JlYXRlZFxuICAgIG1hdGNoLml0ZXJhdG9yfD0wO1xuICAgIC8vZ2V0IG5leHQgaXRlcmF0aW9uXG4gICAgdmFyIHZhbCA9IG1hdGNoLmNvbnRleHRbbWF0Y2guaXRlcmF0b3IrK107XG4gICAgLy9pZiBpdGVyYXRpb24gaXMgbm90IHVuZGVmaW5lZCBwYXJzZS5TVEVQX0lOIGludG8gbmV4dCBpdGVyYXRpb25cbiAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBbcGFyc2UuU1RFUF9JTiwgdmFsXVxuICAgIH1cbiAgICAvL290aGVyd2lzZSBwYXJzZS5TVEVQX09VVFxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFtwYXJzZS5TVEVQX09VVF07XG4gICAgfVxuIHR9LFxuICBzdHJpbmc6IGZ1bmN0aW9uIGxpdGVyYWxtYXRjaChtYXRjaCwgdGV4dFRvUGFyc2UpIHtcbiAgICAvL05vdGU6IEkgaGFkIHRvIGFkZCBjb21tZW50cyBiZWNhdXNlIHJlYWRpbmcgd2FzIHRydWx5IGEgcGFpblxuICAgIC8vdHJpbSB0ZXh0IHRvIHBhcnNlIHRvIGJlIGFzIGxvbmcgYXMgc3RyaW5nIHRvIG1hdGNoIChmcm9tIGluZGV4T2YpLCBsZXQgdGhhdC4gYmUgc3RyXG4gICAgdmFyIHN0ciA9IHRleHRUb1BhcnNlLnN1YnN0cihtYXRjaC5pbmRleE9mLShtYXRjaC5yZXZlcnNlP21hdGNoLmNvbnRleHQubGVuZ3RoOjApLCBtYXRjaC5jb250ZXh0Lmxlbmd0aCksXG4gICAgICAvL3RyaW0gc3RyaW5nIHRvIG1hdGNoLCB0byBiZSBhcyBsb25nIGFzIHN0ciBpcyAoZnJvbSBtYXRjaC5pbmRleE9mLXBhcnNlQ29udGV4dC5pbmRleE9mKSwgbGV0IHRoYXQgYmUgc3RyMlxuICAgICAgc3RyMiA9IG1hdGNoLmNvbnRleHQuc3Vic3RyKG1hdGNoLmluZGV4T2YgLSBtYXRjaC5zdGFydEluZGV4T2YsIHN0ci5sZW5ndGgpXG4gICAgLy9zdHIyIGlzIG5lZWRlZCBpbiBvcmRlciB0byBtYXRjaCBwYXJ0aWFsIG1hdGNoZXMgd2hlbiB0aGUgdGV4dCB0byBwYXJzZSBpcyBpbmNvbXBsZXRlXG4gICAgLy9tYXRjaC5pbmRleE9mIGlzIGxvY2FsIGluZGV4T2YsIHRoaXMgd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSBwYXJzZUNvbnRleHQuaW5kZXhPZiAodGhlIGV4cHJlc3Npb25GZWF0dXJlIGluZGV4T2YpIGlmIHBhcnNlciBoYXMgYmVlbiBoYWx0ZWQgYmVmb3JlXG4gICAgLy9pZiBzdHIgZXF1YWxzIHN0cjJcbiAgICBpZiAoc3RyID09PSBzdHIyKSB7XG4gICAgICAvL21hdGNoLmluZGV4T2YgKGN1cnNvcikgaXMgbW92ZWQgdGhlIHN0ciAob3Igc3RyMikgZGlzdGFuY2VcbiAgICAgIG1hdGNoLmluZGV4T2YgKz0gc3RyLmxlbmd0aCoobWF0Y2gucmV2ZXJzZT8tMToxKTtcbiAgICAgIC8vaWYgc3RyaW5nIHRvIG1hdGNoIGlzIGxvbmdlciB0aGFuIHN0ciB0aGVuIEhBTFQgKGFzc3VtZSB0aGF0IHRleHQgdG8gcGFyc2UgaXMgbm90IGNvbXBsZXRlKVxuICAgICAgaWYgKG1hdGNoLmNvbnRleHQubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgICAgICBpZihtYXRjaC5pc0ZpbmFsKCkpcmV0dXJuIFtwYXJzZS5USFJPVyxcIlN0cmluZyBtYXRjaDogRU9GIFJlYWNoZWRcIl1cbiAgICAgICAgcmV0dXJuIFtwYXJzZS5IQUxUXVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIC8vZWxzZSBwYXJzZS5TVEVQX09VVFxuICAgICAgICAvL25vIHJlc3VsdCBiZWNhdXNlIGxpdGVyYWwgbWF0Y2ggaXMgbGl0ZXJhbFxuICAgICAgICBtYXRjaC5yZXN1bHQ9c3RyMjsvL3Jlc3VsdCBiZWNhdXNlIGRlYnVnZ2luZy5cbiAgICAgICAgcmV0dXJuIFtwYXJzZS5TVEVQX09VVF07XG4gICAgICB9XG4gICAgfVxuICAgIC8vZWxzZSBwYXJzZS5USFJPV1xuICAgIGVsc2Uge1xuICAgICAgLy9kZWJ1Z2dlclxuICAgICAgcmV0dXJuIFtwYXJzZS5USFJPVywgXCJTdHJpbmcgRXJyb3I6IGV4cGVjdGVkIFxcXCJcIiArIG1hdGNoLmNvbnRleHQgKyBcIlxcXCIsIGZvdW5kIFxcXCJcIiArIHN0ciArIFwiXFxcIiBhdCBpbmRleDpcIiArIG1hdGNoLmluZGV4T2ZdXG4gICAgfVxuICB9LFxuICBtZXRhOiB7IHJlc3RvcmFibGU6IFtcInJlcGV0aXRpb25cIiwgXCJvclwiXSB9LFxuICBvYmplY3Q6IHtcbiAgICByZXBldGl0aW9uOiBmdW5jdGlvbiBxdWFudGlmaWVyKG1hdGNoKSB7XG4gICAgICAvL1JlcGV0aXRpb25zIGNhbiBiZSBncmVlZHksIGxhenksIHBvc3Nlc3NpdmVcbiAgICAgIC8vaWYgbWF0Y2gubWF0Y2hlcyBkb2Vzbid0IGV4aXN0IGNyZWF0ZSBvbmVcbiAgICAgIC8vbWF0Y2gubWF0Y2hlcyBpcyB1c2VkIHRvIHN0b3JlIHRoZSBkaWZmZXJlbnQgbWF0Y2hlcyB0aGF0IHRoZSByZXBldGl0aW9uIGhhcyBjYXVnaHQuXG4gICAgICBpZiAoIW1hdGNoLm1hdGNoZXMpIHtcbiAgICAgICAgbWF0Y2gubWF0Y2hlcyA9IFtdXG4gICAgICB9XG4gICAgICAgICAgICAvL2lmIHBhcnNlIHRyZWUgd2FzIHJlc3RvcmVkXG4gICAgICAvL3RoZW4ga2VlcCB0cnlpbmcgdG8gbWF0Y2ggYW5vdGhlciBvcHRpb24sIGlmIGdyZWVkeSB0YWtlIDEgbGVzcywgaWYgbGF6eSB0YWtlIDEgbW9yZVxuICAgICAgaWYgKG1hdGNoLnJlc3RvcmVkKSB7XG4gICAgICAgIG1hdGNoLnJlc3RvcmVkID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAobWF0Y2guY29udGV4dC5xdWFudGlmaWVyKSB7XG4gICAgICAgICAgY2FzZSBcImdyZWVkeVwiOlxuICAgICAgICAgICAgLy9hdHRlbXB0IHRvIHRha2UgMSBsZXNzIHVuaXQsIGlmIHRoZXJlIGlzIGxlc3MgdGhhbiBmcm9tLCByZXBldGl0aW9uIGZhaWxzXG4gICAgICAgICAgICBpZiAobWF0Y2gubWF0Y2hlcy5sZW5ndGggPiBtYXRjaC5jb250ZXh0LmZyb20pIHtcbiAgICAgICAgICAgICAgbWF0Y2gubWF0Y2hlcy5wb3AoKTtcbiAgICAgICAgICAgICAgLy9tYXRjaC5yZXN1bHQucG9wKCk7XG4gICAgICAgICAgICAgIG1hdGNoLmluZGV4T2YgPSBtYXRjaC5tYXRjaGVzW21hdGNoLm1hdGNoZXMubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgcmV0dXJuIFtwYXJzZS5TVEVQX09VVF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gW3BhcnNlLlRIUk9XLCBcIkF0dGVtcHRlZCB0byB0YWtlIDEgbGVzcyB1bml0IGluIGdyZWVkeSBwYXR0ZXJuLCBpbiBcIiArIG1hdGNoLmluZGV4T2YgKyBcIiBidXQgZG9pbmcgc28gZXhjZWVkZWQgdGhlIGRlZmluZWQgYm91bmRzLlwiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImxhenlcIjpcbiAgICAgICAgICAgIC8vYXR0ZW1wdCB0byB0YWtlIDEgbW9yZSB1bml0LCBpZiBpdCBmYWlscywgcmVwZXRpdGlvbiBmYWlsc1xuICAgICAgICAgICAgaWYgKG1hdGNoLm1hdGNoZXMubGVuZ3RoIDwgbWF0Y2guY29udGV4dC50bykge1xuICAgICAgICAgICAgICBtYXRjaC5sYXp5cGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgIC8vZGVzcGl0ZSB0aGUgcGF0dGVybiBpcyBsYXp5LCBpdCBoYXMgZmFpbGVkIHNvIGl0IG11c3QgdGFrZSB0aGUgZm9sbG93aW5nIHN0ZXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gW3BhcnNlLlRIUk9XLCBcIkF0dGVtcHRlZCB0byB0YWtlIDEgbW9yZSB1bml0IGluIGxhenkgcGF0dGVybiwgaW4gXCIgKyBtYXRjaC5pbmRleE9mICsgXCIgYnV0IGRvaW5nIHNvIGV4Y2VlZGVkIHRoZSBkZWZpbmVkIGJvdW5kcy5cIl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2lmIGNoaWxkcmVuIHJldHVybmVkIHJlc3VsdFxuICAgICAgZWxzZSBpZiAobWF0Y2guY2hpbGRTdGVwKSB7XG4gICAgICAgIGlmIChtYXRjaC5jaGlsZFN0ZXAucmVzdWx0KSB7XG4gICAgICAgICAgaWYgKCFtYXRjaC5yZXN1bHQpIHtcbiAgICAgICAgICAgIG1hdGNoLnJlc3VsdCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXRjaC5yZXN1bHQucHVzaChtYXRjaC5jaGlsZFN0ZXAucmVzdWx0KTtcbiAgICAgICAgICBtYXRjaC5tYXRjaGVzLnB1c2gobWF0Y2guaW5kZXhPZilcbiAgICAgICAgfVxuICAgICAgICAvL1JlYXNvbnMgZm9yIFJlcGV0aXRpb24gdG8gZW5kXG4gICAgICAgIC8vUmVwZXRpdGlvbiBpdGVyYXRpb24gdGhyZXcgZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIG1hdGNoIG5leHQgcmVwZXRpdGlvbiBpdGVtXG4gICAgICAgIC8vUmVwZXRpdGlvbiByZWFjaGVkIG1heGltdW0gbnVtYmVyIG9mIGl0ZW1zXG4gICAgICAgIGlmIChtYXRjaC5jaGlsZFN0ZXAuZmFpbCB8fCAobWF0Y2gubWF0Y2hlcy5sZW5ndGggPT09IG1hdGNoLmNvbnRleHQudG8pKSB7IC8vY291bGQgYmUgcmVzdG9yZWQsIG9yIGNvdWxkIGJlIGdyb3VwIHZhbHVlIHdhcyBmYWxzeVxuICAgICAgICAgIC8vTm90IGJ1YmJsaW5nIGVycm9ycyB1cC5cbiAgICAgICAgICAvL2lmIGxvb3AgZmFpbGVkXG4gICAgICAgICAgLy9jaGVjayBpZiBsb29wIHJlcXVpcmVtZW50cyBtYXRjaCBvciBpZiBpdHMgbGF6eSAoaWYgaXQncyBsYXp5IHRoYXQgbWVhbnMgdGhhdCBhbiBhdHRlbXB0IHRvIG1hdGNoIGZhaWxlZCB0aGVyZWZvcmUgcGF0dGVybiBmYWlsZWQgdG8gbWF0Y2gpXG4gICAgICAgICAgaWYgKChtYXRjaC5jb250ZXh0LnF1YW50aWZpZXIgIT09IFwibGF6eVwiKSAmJiAobWF0Y2guY29udGV4dC5mcm9tIDw9IG1hdGNoLm1hdGNoZXMubGVuZ3RoICYmIG1hdGNoLmNvbnRleHQudG8gPj0gbWF0Y2gubWF0Y2hlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAvL3JlcXVpcmVtZW50cyBzZWVtIHRvIGZpdCFcbiAgICAgICAgICAgIGlmKG1hdGNoLmNoaWxkU3RlcC5pbmRleE9mKXtcbiAgICAgICAgICAgICAgbWF0Y2guaW5kZXhPZj1tYXRjaC5jaGlsZFN0ZXAuaW5kZXhPZlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtwYXJzZS5TVEVQX09VVF1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7IC8vcmVxdWlyZW1lbnRzIGRvbnQgbWF0Y2hcbiAgICAgICAgICAgIHJldHVybiBbcGFyc2UuVEhST1csIFwiUmVwZXRpdGlvbiBlbmRlZCBhdCBcIiArIG1hdGNoLmluZGV4T2YgKyBcIiBhbmQgZWl0aGVyIHJlcGV0aXRpb24gZXhjZWVkZWQgYm91bmRzIG9yIGZhaWxlZCBtYXRjaGluZyBhIGxhenkgcGF0dGVyblwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9pZiBpdGVyYXRvciBpcyBiaWdnZXIgdGhhbiBmcm9tIGFuZCBpdCBpcyBsYXp5IGJ1dCBpdHMgbm90IGxhenlwYXNzZWQsIHRoZW5cbiAgICAgIGlmICgobWF0Y2gubWF0Y2hlcy5sZW5ndGggPiBtYXRjaC5jb250ZXh0LmZyb20pICYmIChtYXRjaC5jb250ZXh0LnF1YW50aWZpZXIgPT09IFwibGF6eVwiKSAmJiAoIW1hdGNoLmxhenlwYXNzKSkge1xuICAgICAgICBpZihtYXRjaC5jaGlsZFN0ZXAuaW5kZXhPZil7XG4gICAgICAgICAgICAgIG1hdGNoLmluZGV4T2Y9bWF0Y2guY2hpbGRTdGVwLmluZGV4T2ZcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtwYXJzZS5TVEVQX09VVF1cbiAgICAgIH1cbiAgICAgIG1hdGNoLmxhenlwYXNzID0gZmFsc2U7XG4gICAgICByZXR1cm4gW3BhcnNlLlNURVBfSU4sIG1hdGNoLmNvbnRleHQuY2hpbGRdO1xuICAgIH0sXG4gICAgcG9pbnRlcjogZnVuY3Rpb24obWF0Y2gsIHRleHRUb1BhcnNlKSB7XG4gICAgICBpZiAobWF0Y2guY2hpbGRTdGVwKSB7XG4gICAgICAgIGlmKG1hdGNoLmNoaWxkU3RlcC5mYWlsKVxuICAgICAgICByZXR1cm4gW3BhcnNlLlRIUk9XLFwicG9pbnRlciBmYWlsZWRcIl1cbiAgICAgICAgbWF0Y2gucmVzdWx0ID0gbWF0Y2guY2hpbGRTdGVwLnJlc3VsdDtcbiAgICAgICAgbWF0Y2guaW5kZXhPZj1tYXRjaC5jaGlsZFN0ZXAuaW5kZXhPZlxuICAgICAgICByZXR1cm4gW3BhcnNlLlNURVBfT1VUXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbcGFyc2UuU1RFUF9JTiwgbWF0Y2guZ3JhbW1hcktleShtYXRjaC5jb250ZXh0LnZhbHVlKV07XG4gICAgfSxcbiAgICBvcjogZnVuY3Rpb24gYWx0ZXJuYXRpb24obWF0Y2gpIHsgLy93ZWxsIHNoaXRcbiAgICAgIC8ve3R5cGU6XCJvclwiLGNoaWxkOm5vZGVbXX1cbiAgICAgIGlmIChtYXRjaC5jaGlsZFN0ZXApIHtcbiAgICAgICAgaWYgKChtYXRjaC5jaGlsZFN0ZXAuZmFpbHx8bWF0Y2gucmVzdG9yZWQpICYmIChtYXRjaC5jb250ZXh0LmNob2ljZXMubGVuZ3RoID09PSBtYXRjaC5pdGVyYXRvcikpIHsgLy9ub25lIG9mIHRoZSBjaG9pY2VzIHdvcmtcbiAgICAgICAgICByZXR1cm4gW3BhcnNlLlRIUk9XLCBcIkFsdGVybmF0aW9uIEVycm9yOiBOb25lIG9mIHRoZSBvcHRpb25zIGluIHRoZSBhbHRlcm5hdGlvbiBtYXRjaC4gQXQgaW5kZXggXCIgKyBtYXRjaC5pbmRleE9mXVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCghbWF0Y2guY2hpbGRTdGVwLmZhaWwpICYmIChtYXRjaC5pdGVyYXRvciAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgIGlmKG1hdGNoLmNoaWxkU3RlcC5yZXN1bHQpe1xuICAgICAgICAgIG1hdGNoLnJlc3VsdCA9IG1hdGNoLmNoaWxkU3RlcC5yZXN1bHQ7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBtYXRjaC5yZXN1bHQ9bWF0Y2guaXRlcmF0b3JcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0Y2guaW5kZXhPZj1tYXRjaC5jaGlsZFN0ZXAuaW5kZXhPZlxuICAgICAgICAgIHJldHVybiBbcGFyc2UuU1RFUF9PVVRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG1hdGNoLml0ZXJhdG9yIHw9MDtcbiAgICAgIHZhciB2ID0gbWF0Y2guY29udGV4dC5jaG9pY2VzW21hdGNoLml0ZXJhdG9yKytdO1xuICAgICAgaWYgKHYpIHtcbiAgICAgICAgcmV0dXJuIFtwYXJzZS5TVEVQX0lOLCB2XTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW3BhcnNlLlRIUk9XLCBcIkFsdGVybmF0aW9uIEVycm9yOiBOb25lIG9mIHRoZSBvcHRpb25zIGluIHRoZSBhbHRlcm5hdGlvbiBtYXRjaC4gQXQgaW5kZXggXCIgKyBtYXRjaC5pbmRleE9mXVxuICAgICAgfVxuICAgIH0sXG4gICAgLy93aWxkY2FyZCBhbHdheXMgbWF0Y2hlcyBhIGNoYXJhY3RlclxuICAgIHdpbGRjYXJkOmZ1bmN0aW9uIHdpbGRjYXJkKG1hdGNoLHRleHQpe1xuLy97dHlwZTpcIndpbGRjYXJkXCIsdmFsdWU6W3tmcm9tOjUsdG86N30sXCJhXCIsXCJiXCJdLG5lZ2F0aXZlOmZhbHNlfVxuICAgICAgdmFyIHQ9dGV4dFttYXRjaC5pbmRleE9mLW1hdGNoLnJldmVyc2VdLHZcbiAgICAgIGlmKCF0KSAgICByZXR1cm4gW3BhcnNlLlRIUk9XLFwiV2lsZGNhcmQgY2FuJ3QgbWF0Y2ggZW1wdHkgc3RyaW5nXCJdO1xuICAgICAgdj1tYXRjaC5jb250ZXh0LnZhbHVlLmZpbmQoZnVuY3Rpb24oYSl7aWYodHlwZW9mIGE9PT1cIm9iamVjdFwiKXtyZXR1cm4gYS50bz49dC5jaGFyQ29kZUF0KCk+PWEuZnJvbX1lbHNle3JldHVybiBhPT09dH19KVxuICAgICAgdj1tYXRjaC5jb250ZXh0Lm5lZ2F0aXZlPyh2P2ZhbHNlOnQpOnY7XG4gICAgICBpZih0PT09XCJcIil7XG4gICAgICAgIGlmKG1hdGNoLmlzRmluYWwoKSl7XG4gICAgICAgICAgICByZXR1cm4gW3BhcnNlLlRIUk9XLFwiV2lsZGNhcmQgY2FuJ3QgbWF0Y2ggZW1wdHkgc3RyaW5nXCJdO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIFtwYXJzZS5IQUxUXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH1cbiAgICAgIGlmICh2KSB7XG4gICAgICAgIG1hdGNoLnJlc3VsdD10O1xuICAgICAgICAvL0kgU0VSSU9VU0xZIENIQU5HSU5HIFRIRSBJTkRFWE9GIFdIRU4gVEhFIEVORCBPRiBcbiAgICAgICAgbWF0Y2guaW5kZXhPZis9KG1hdGNoLnJldmVyc2UmJi0xKXwxOy8vbWF0Y2gucmV2ZXJzZT8tMToxXG4gICAgICAgIHJldHVybiBbcGFyc2UuU1RFUF9PVVRdO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbcGFyc2UuVEhST1csIFwiTm8gdmFsdWUgZm9yIHdpbGRjYXJkXCJdXG4gICAgICB9XG4gICAgfSxyZXZlcnNlOmZ1bmN0aW9uKG1hdGNoKXtcbiAgICAgIG1hdGNoLnJldmVyc2U9IW1hdGNoLnJldmVyc2VcbiAgICAgIGlmKG1hdGNoLmNoaWxkU3RlcCl7XG4gICAgICAgIGlmKG1hdGNoLmNoaWxkU3RlcC5mYWlsKSByZXR1cm4gW3BhcnNlLlRIUk9XLG1hdGNoLmNoaWxkU3RlcC5mYWlsTXNnXVxuICAgICAgICBtYXRjaC5yZXN1bHQ9bWF0Y2guY2hpbGRTdGVwLnJlc3VsdDtcbiAgICAgICAgbWF0Y2guaW5kZXhPZj1tYXRjaC5jaGlsZFN0ZXAuaW5kZXhPZlxuICAgICAgICByZXR1cm4gW3BhcnNlLlNURVBfT1VUXVxuICAgICAgfVxuICAgICAgcmV0dXJuIFttYXRjaC5TVEVQX0lOLG1hdGNoLmNvbnRleHQudmFsdWVdXG4gICAgfSx2YXJpYWJsZTpmdW5jdGlvbihtYXRjaCl7XG4gICAgICB2YXIgdmFyaWFibGVzPW1hdGNoLnZhcmlhYmxlKCk7XG4gICAgICBpZihtYXRjaC5jaGlsZFN0ZXApe1xuICAgICAgICAvL0kgdGhpbmsgbW9zdCBzdGVwcyByZXR1cm4gYSByZXN1bHQgYW5kIGFuIGluZGV4T2YgdG8gcGFyZW50XG4gICAgICAgIGlmKG1hdGNoLmNoaWxkU3RlcC5mYWlsKSByZXR1cm4gW3BhcnNlLlRIUk9XLG1hdGNoLmNoaWxkU3RlcC5mYWlsTXNnXVxuICAgICAgICBtYXRjaC5yZXN1bHQ9dmFyaWFibGVzW21hdGNoLmNvbnRleHQua2V5XT1tYXRjaC5jaGlsZFN0ZXAucmVzdWx0O1xuICAgICAgICBtYXRjaC5pbmRleE9mPW1hdGNoLmNoaWxkU3RlcC5pbmRleE9mXG4gICAgICAgIHJldHVybiBbcGFyc2UuU1RFUF9PVVRdXG4gICAgICB9XG4gICAgICBpZih0eXBlb2YgbWF0Y2guY29udGV4dC52YWx1ZT09XCJ1bmRlZmluZWRcIil7XG4gICAgICAgIG1hdGNoLnJlc3VsdD12YXJpYWJsZXNbbWF0Y2guY29udGV4dC5rZXldXG4gICAgICAgIGlmKCFtYXRjaC5yZXN1bHQpe1xuICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIlZhbHVlIGlzIHVuZGVmaW5lZCwgYW5kIHRoZXJlIGlzIG5vIHZhcmlhYmxlS2V5IFxcXCJcIittYXRjaC5jb250ZXh0LmtleStcIlxcXCIgc2V0LlwiKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbcGFyc2UuU1RFUF9JTixtYXRjaC5yZXN1bHRdXG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIFtwYXJzZS5TVEVQX0lOLG1hdGNoLmNvbnRleHQudmFsdWVdXG4gICAgICB9XG4gICAgfSxhc3NlcnRpb246ZnVuY3Rpb24obWF0Y2gsdGV4dCl7XG4gICAgICAvL3t0eXBlOlwiYXNzZXJ0aW9uXCIsdmFsdWU6PHBhdHRlcm4+LFtuZWdhdGl2ZTo8Ym9vbGVhbj5dfVxuICAgICAgIGlmKG1hdGNoLmNoaWxkU3RlcCl7XG4gICAgICAgIGlmKG1hdGNoLmNoaWxkU3RlcC5mYWlsIT09bWF0Y2gubmVnYXRpdmUpIFxuICAgICAgICByZXR1cm4gW3BhcnNlLlNURVBfT1VUXVxuICAgICAgfVxuICAgICAgLy9FT0YgYXNzZXJ0aW9uc1xuICAgICAgaWYobWF0Y2guY29udGV4dC52YWx1ZT09PVwiXCIpe1xuICAgICAgICBpZihtYXRjaC5pbmRleE9mPT09dGV4dC5sZW5ndGgpe1xuICAgICAgICAgIHJldHVybiBbcGFyc2UuU1RFUF9PVVRdXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHJldHVybiBbcGFyc2UuVEhST1csXCJBc3NlcnRpb24gZmFpbGVkXCJdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbbWF0Y2guU1RFUF9JTixtYXRjaC5jb250ZXh0LnZhbHVlXVxuICAgICAgXG4gICAgfSxhdG9taWM6ZnVuY3Rpb24obWF0Y2gpe1xuICAgICAgbWF0Y2guYXRvbWljaXR5PW1hdGNoLnJlc3RvcmU7XG4gICAgIGlmKG1hdGNoLmNoaWxkU3RlcCl7XG4gICAgICAgIGlmKG1hdGNoLmNoaWxkU3RlcC5mYWlsKSByZXR1cm4gW3BhcnNlLlRIUk9XLG1hdGNoLmNoaWxkU3RlcC5mYWlsTXNnXVxuICAgICAgICBtYXRjaC5yZXN1bHQ9bWF0Y2guY2hpbGRTdGVwLnJlc3VsdDtcbiAgICAgICAgbWF0Y2guaW5kZXhPZj1tYXRjaC5jaGlsZFN0ZXAuaW5kZXhPZlxuICAgICAgICByZXR1cm4gW3BhcnNlLlNURVBfT1VUXVxuICAgICAgfVxuICAgICAgcmV0dXJuIFttYXRjaC5TVEVQX0lOLG1hdGNoLmNvbnRleHQudmFsdWVdXG4gICAgfVxuICB9LFxuICBudWxsOiBmdW5jdGlvbigpIHsgcmV0dXJuIFtwYXJzZS5USFJPVywgXCJhdHRlbXB0ZWQgdG8gbWF0Y2ggbnVsbFwiXSB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cHJlc3Npb25GZWF0dXJlcztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lang.js\n");

/***/ }),

/***/ "./parser-constants.js":
/*!*****************************!*\
  !*** ./parser-constants.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n\tverbose : false,\nSTEP_OUT : 1,\nSTEP_IN : 2,\nRemoveNode : 6,\nTHROW : 0,\nHALT : 3, //it haltes loop without going further in or out\nSaveStateOut : 4,\nSaveStateIn : 5}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYXJzZXItY29uc3RhbnRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcGFyc2VyLWNvbnN0YW50cy5qcz9jMjczIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge1xuXHR2ZXJib3NlIDogZmFsc2UsXG5TVEVQX09VVCA6IDEsXG5TVEVQX0lOIDogMixcblJlbW92ZU5vZGUgOiA2LFxuVEhST1cgOiAwLFxuSEFMVCA6IDMsIC8vaXQgaGFsdGVzIGxvb3Agd2l0aG91dCBnb2luZyBmdXJ0aGVyIGluIG9yIG91dFxuU2F2ZVN0YXRlT3V0IDogNCxcblNhdmVTdGF0ZUluIDogNX1cblxuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./parser-constants.js\n");

/***/ }),

/***/ "./parser.js":
/*!*******************!*\
  !*** ./parser.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*I want to build a generic parser, that parses RegEx, \nand it's pausable by itself, I'm doing this for a project.*/ \nvar Tree=__webpack_require__(/*! ./tree.js */ \"./tree.js\")\n//Get Type\nfunction getType(value) { //returns a string getting the type of the object: array, object, integer, etc. Taken from Chrome's code.\n  var s = typeof value;\n  if (s == \"object\") {\n    if (value === null) {\n      return \"null\";\n    }\n    else if (Object.prototype.toString.call(value) == \"[object Array]\") {\n      return \"array\";\n    }\n    else if (typeof(ArrayBuffer) != \"undefined\" &&\n      value.constructor == ArrayBuffer) {\n      return \"binary\";\n    }\n  }\n  else if (s == \"number\") {\n    if (value % 1 == 0) {\n      return \"integer\";\n    }\n  }\n  return s;\n};\n\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function(searchElement /*, fromIndex*/ ) {\n    'use strict';\n    var O = Object(this);\n    var len = parseInt(O.length) || 0;\n    if (len === 0) {\n      return false;\n    }\n    var n = parseInt(arguments[1]) || 0;\n    var k;\n    if (n >= 0) {\n      k = n;\n    }\n    else {\n      k = len + n;\n      if (k < 0) { k = 0; }\n    }\n    var currentElement;\n    while (k < len) {\n      currentElement = O[k];\n      if (searchElement === currentElement ||\n        (searchElement !== searchElement && currentElement !== currentElement)) { // NaN !== NaN\n        return true;\n      }\n      k++;\n    }\n    return false;\n  };\n}\n/*\nUSAGE&EXAMPLES: \nThis function accepts a grammar object, and a string to parse. Grammar objects contain the information needed to parse whichever the string contains.\nA grammar object is a map (an associative array), in which it's keys are labels given by the programmer with the exception of the \"grammar\" label which is the initial/starting/main key, the values are patterns:\nThis is defined by expressionFeatures (parserSteppers), and behavour can be changed by so\nA pattern/feautre is either an object, a native array or a string, they can be:\n\n<pattern>:\ndef:(<pattern>[]|<string>|{type:\"repetition\",to:<int>,from:<int>,quantifier:(\"lazy\"|\"greedy\"),child:<pattern>}|{type:\"or\",child:<pattern>[]}|{type:\"wildcard\",value:({from:<int>,to:<int>}|<char>)[][,negative:<boolean>]}|{type:\"pointer\",value:<string>}|{type:\"var\",key:<string>[,set:<pattern>]})\n\n #An array (basically a noncapturing group)\n  Description: concantenated patterns, or a progression/sequence/continuum of patterns \n  def:<pattern>[]\n  Usage example: [pattern1,pattern2]\n   *they would be described in a native array of <pattern>s \n\n   *the result is an array of children results, if children don't result, no result is thrown.\n   \n #A repetition/quantifier \n  Description: pattern, used in order to match repeated sequences*\n  def:{type:\"repetition\",to:<int>,from:<int>,quantifier:(\"lazy\"|\"greedy\"),child:<pattern>}\n   *the result is an array of children results, if children don't result, no result is thrown.\n  Well, I know this is a bit lazy, but I had to consider that repetitions could return two totally different results for alternation patterns\n  TODO: indicate result repetition\n  \n #(A choice|An alternation)\n  Description: An alternation allows to match pattern or another pattern exclusively\n  def:{type:\"or\",child:<pattern>[]}\n  \n#A (wildcard/range|character class)\n  Description:allows a character to match the values given\n  def:{type:\"wildcard\",value:({from:(<int>|<char>),to:(<int>|<char>)}|<char>)[][,negative:<boolean>]}\n  Usage example: {type:\"wildcard\",value:[{from:5,to:7},\"a\",\"b\"],negative:false}\n  The range pattern value is an array which contains the desired characters to match, or an object containing a from, to. The latter is a range mathing the character codes.\n  \n  \n#A pointer\n  Description: a pointer allows recursiveness, so you can define many key patterns in grammar, and you switch to them\n  def:  {type:\"pointer\",value:<string>}\n  Usage example: {type:\"pointer\",value:\"grammar\"} //would point to the main key\n \n#Variables\n  def: {type:\"variable\",key:<string>[,value:<pattern>]}\n  Usage example: {type:\"var\",key:\"your key\",set:node}\n  When there is no \"set\" it will attempt to get the value of the variable.\n \n#A string pattern \n  Description: matches a string literally\n  def:<string>\n  would be just described as a normal string\n \n#An assertion (lookahead)\n def:{type:\"assertion\",value:<pattern>,[negative:<boolean>]}\n These are zero-length assertions like lookarounds or \\b in regex, basically conditional expressions these are btw atomic\n \n#A reverse statment\n  Description: will start matching <pattern> in reverse, why would you do this? Doesn't reverse order of strings, so this will confuse you :)\n  def:{type:\"reverse\",value:<pattern>}\n  Usage example:{type:\"reverse\",value:[\"ab\",\"ta\"]}//will only match taab\n  Normally matches are RTL but if you want to match it LTR that is fine too, please consider that this will just reverse the direction of the cursor, literal strings should work RTL just as fine, but arrays and other orbjects will be read as given\n  (Nested reverses will match again RTL)\n  \n#An atomic node\n  Description: makes a pattern atomic, Atomic nodes would disallow bakctracking when it does return.\n  def: {type:\"atomic\",value:<pattern>} \n  \n \nNote that regex /a?/ would be described as a quantifier pattern, like /a{0,1}/\nfor example, the pattern [\"human\",{type:\"repetition\",to:0,from:1,child:\"s\"}] would match \"human\" and \"humans\"\nIt's not intended for a programmer to write the pattern themselves, since they're mostly a translation of regex. a representation of em\n*Alright but before we continue, we must first mention 2 patterns that can actually change its content, those are alternations and quantifiers.\nbecause alternations and quantifiers can match before all their possibilities are tested, we need a way for them to store their state.\n\nA restore triggers when parent expression indexOf is lesser than where restore is from.\n*/\n\n//So, this long expected \"reader-macro begins\"\nvar asdf=[]\nfunction parse(parserSteppers, grammar, textToParse, parseContext, final, timeOut) { //function start\n  /*Since coding this is taking way longer than usual, I'd better write the specifications of this function.\n  This function takes a grammar, a string and a parseContext, it returns a parseContext. This function should be able to return parsing contexts for incomplete strings of data. It takes a parseContext if this function has been called before and it retakes the job from there.\n  The grammar is specified in an object, the rules are above this function.\n  textToParse is of type string, it's the string about to be parsed\n  parseContext, is null, its only used when textToParse was \"incomplete\" last time, and now there's more information in order to finish parsing\n  final, default to true, if false it means that the textToParse is not complete, and it will just attempt to parse what it can with what it has, it will halt when it cannot read more\n  */\n  /**/\n  //Step constructor\n  function Step(context, index) {\n    if (!(context instanceof this.constructor)) { this.context = context;\n    this.indexOf = index;\n    this.startIndexOf = index;\n    this.result = null }else{\n      Object.assign(this,context)\n      this.result=this.result&&this.result.slice(0)\n      if(this.matches)this.matches=this.matches.slice(0)\n    }\n    this.restore = parseContext.restore;\n    this.reverse = parseContext.reverse;\n    //if(!this.context){throw new Error('No context given!')}\n  }//This must be wrong, forgive me\n    Step.prototype.grammarKey = function(val) {\n      return grammar[val]\n    }\n    Step.prototype.variable = function() {\n      return parseContext.variables\n    }\n    Step.prototype.isFinal=function(){\n      return final;\n    }\n    if(final===void 0)final=true;\n  if (!parseContext) { //if there is no parseContext, create one\n    parseContext = { indexOf: 0, fail: false, restore: 0, result: null, variables:{},reverse:false };\n    //A restore value is a map that contains 3 elements\n    parseContext.root=new Tree(\"root\")\n    parseContext.stepInfo = parseContext.root.addChild(new Step(grammar.grammar, 0));\n  }\n  function stepInProcedure(context) {\n    var startIndexOf = parseContext.stepInfo.data.indexOf;\n    parseContext.stepInfo = parseContext.stepInfo.addChild(new Step(context, startIndexOf));\n  }\n  function stepOutProcedure(f) {\n    //function is called when function has checked and it was to continue to the next iteration\n    //f is a boolean value saying the match fail is true, if if is true, the match failed\n    //fun fact: if the function returns false, it will bubble up until it finds a lower restorable value and then bubble down\n    \n    var childStep = parseContext.stepInfo, childData = childStep.data, s;\n    parseContext.stepInfo = parseContext.stepInfo.parent;\n    \n      if (f&&(s=childStep.previousSibling())) {\n        //If function failed but it has a sibling, restore that sibling\n      parseContext.restore--;\n      childStep.detachFromParent()\n      while(s=s.getLastChild()){\n        parseContext.stepInfo=s\n      }\n      parseContext.stepInfo.childStep=null\n      parseContext.stepInfo.data.restored=true;\n      return;\n    } \n    if(parseContext.stepInfo.data==\"root\"){\n        childData.fail = f\n        return}\n    if (childData.restore === parseContext.restore) {\n      childStep.detachFromParent()\n      /*if(parseContext.stepInfo.data.restore!== parseContext.restore){\n        parseContext.stepInfo=parseContext.stepInfo.parent.addChild(new Step(parseContext.stepInfo.data))\n        }*/\n    }//else\n       if(parseContext.stepInfo.data.restore!== parseContext.restore){\n      parseContext.stepInfo=parseContext.stepInfo.parent.addChild(new Step(parseContext.stepInfo.data))\n        \n      }\n      /*else {parseContext.stepInfo=new Step(parseContext.stepInfo.data);\n      throw new Error('wait, no parent??');\n      }*/\n    \n    parseContext.stepInfo.data.childStep = childData\n    //THIS SHOULD BE SOME KIND OF PARENT FLAG\n    childData.fail = f\n    //NOOOOO parseContext.stepInfo.data.indexOf = childData.indexOf;\n    return;\n  }\n  mainloop: //begins looping over grammar object\n    do {\n//console.log('executed mainloop');\n      var match = parseContext.stepInfo.data,\n        type = getType(match.context);\n      var stepper = parserSteppers[type],\n        nextParseInstruction;\n      if (type === \"object\") {\n        stepper = stepper[match.context.type];\n      }\n      //coolTree=(function(){var ppapa=\"\";parseContext.root.forEach(function(i,ii){    var t=getType(i.data.context);    if(i.data==\"root\"){t=\"root\"}else if(t==\"object\"){        t=i.data.context.type;    }    i.string=ii+\",\"+i.data.restore+\": \"+t+(t==\"array\"?\" length:\"+i.data.context.length+\" iterator:\"+i.data.iterator:\"\")+(t==\"or\"?\" choices:\"+i.data.context.choices.length+\" iterator:\"+i.data.iterator:\"\")+(t==\"string\"?\":\"+i.data.context:\"\")+(t==\"pointer\"?\":\"+i.data.context.value:\"\")+(t==\"repetition\"?\", reps:\"+(i.data.matches&&i.data.matches.length)+\" \"+i.data.context.quantifier:\"\");    if(i.parent&&i.parent.string)  ppapa+=JSON.stringify(i.parent.string)+\"->\"+JSON.stringify(i.string)+\";\\n\";});return ppapa})\n      function getResult(v){if(!v){return null}var m=[];m.push(v.data.result);if(v.children){m=m.concat(getResult(v.children[v.children.length-1]))};return m}\n      coolTree2=(function(){\nvar ppapa=\"\";parseContext.root.forEach(function(i,ii){\n    \n    var t=getType(i.data.context)\n    if(i.data==\"root\"){t=\"root\"}else if(t==\"object\"){\n        t=i.data.context.type\n    }\n    i.string=i.data.restore+\": \"+t+(t==\"array\"?\" length:\"+i.data.context.length+\" iterator:\"+i.data.iterator:\"\")+(t==\"or\"?\" choices:\"+i.data.context.choices.length+\" iterator:\"+i.data.iterator:\"\")+(t==\"string\"?\":\"+i.data.context:\"\")+(t==\"pointer\"?\":\"+i.data.context.value:\"\")+(t==\"repetition\"?\", reps:\"+(i.data.matches&&i.data.matches.length)+\" \"+i.data.context.quantifier:\"\");\n    \n    ppapa+=Array.apply(this,Array(ii)).map(function(){return \"│   \"}).join('')+\"├\"+JSON.stringify(i.string)+\"\\n\"\n});return \"Rollbacktree:\"+ppapa+\"\\nLastResult:\"+getResult(parseContext.root).join()})\n\n\n\n      if(match.indexOf>textToParse.length){\n        //why would the indexOf be bigger than the textToParse?  \n        throw new Error('This should never happen, it means the method before has added too many elements to indexOf greater than the length of the text that must be parsed')\n      }\ndebugger;\n      nextParseInstruction = stepper(match, textToParse);\n      parseContext.reverse=match.reverse;\n      if (type === \"object\"&&parserSteppers.meta.restorable.includes(match.context.type)) {\n        if (nextParseInstruction[0] === parse.STEP_OUT) { nextParseInstruction[0] = parse.SaveStateOut }\n      }\n      //different instructions!\n      switch (nextParseInstruction[0]) {\n        case parse.THROW:\n          if(parse.verbose)console.error(nextParseInstruction[1])\n          match.failMsg=nextParseInstruction[1]\n          stepOutProcedure(true, match);\n          continue;\n          break;\n        case parse.STEP_IN:\n          if(!nextParseInstruction[1]){\n            throw new Error(\"Step requested a step in but no declared instruction to step into.\")\n          }\n          stepInProcedure(nextParseInstruction[1]);\n          continue;\n          break;\n        case parse.SaveStateOut:\n          parseContext.restore++;\n          //parseContext.restore = parseContext.restore.parent;\n        case parse.STEP_OUT:\n          stepOutProcedure(false);\n          break;\n        case parse.HALT:\n          if(parse.verbose)console.log(\"parser halted\")\n          parseContext.halted=true;\n          break mainloop;\n          break;\n      }\n      continue;\n    } while (parseContext.stepInfo.data!==\"root\");\n    parseContext.result=parseContext.root.getLastChild().data.result\n    parseContext.fail=!!parseContext.root.getLastChild().data.fail\n    parseContext.indexOf=parseContext.root.getLastChild().data.indexOf\n    if(!parseContext.fail&&(final||!parseContext.halted))parseContext.fail=parseContext.indexOf!==textToParse.length\n    return parseContext;\n}\n\nObject.assign(parse,__webpack_require__(/*! ./parser-constants.js */ \"./parser-constants.js\"))\nmodule.exports=parse;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYXJzZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYXJzZXIuanM/NjI5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKkkgd2FudCB0byBidWlsZCBhIGdlbmVyaWMgcGFyc2VyLCB0aGF0IHBhcnNlcyBSZWdFeCwgXG5hbmQgaXQncyBwYXVzYWJsZSBieSBpdHNlbGYsIEknbSBkb2luZyB0aGlzIGZvciBhIHByb2plY3QuKi8gXG52YXIgVHJlZT1yZXF1aXJlKCcuL3RyZWUuanMnKVxuLy9HZXQgVHlwZVxuZnVuY3Rpb24gZ2V0VHlwZSh2YWx1ZSkgeyAvL3JldHVybnMgYSBzdHJpbmcgZ2V0dGluZyB0aGUgdHlwZSBvZiB0aGUgb2JqZWN0OiBhcnJheSwgb2JqZWN0LCBpbnRlZ2VyLCBldGMuIFRha2VuIGZyb20gQ2hyb21lJ3MgY29kZS5cbiAgdmFyIHMgPSB0eXBlb2YgdmFsdWU7XG4gIGlmIChzID09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZihBcnJheUJ1ZmZlcikgIT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgdmFsdWUuY29uc3RydWN0b3IgPT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgIHJldHVybiBcImJpbmFyeVwiO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChzID09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAodmFsdWUgJSAxID09IDApIHtcbiAgICAgIHJldHVybiBcImludGVnZXJcIjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59O1xuXG5pZiAoIUFycmF5LnByb3RvdHlwZS5pbmNsdWRlcykge1xuICBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbihzZWFyY2hFbGVtZW50IC8qLCBmcm9tSW5kZXgqLyApIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIE8gPSBPYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbiA9IHBhcnNlSW50KE8ubGVuZ3RoKSB8fCAwO1xuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG4gPSBwYXJzZUludChhcmd1bWVudHNbMV0pIHx8IDA7XG4gICAgdmFyIGs7XG4gICAgaWYgKG4gPj0gMCkge1xuICAgICAgayA9IG47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgayA9IGxlbiArIG47XG4gICAgICBpZiAoayA8IDApIHsgayA9IDA7IH1cbiAgICB9XG4gICAgdmFyIGN1cnJlbnRFbGVtZW50O1xuICAgIHdoaWxlIChrIDwgbGVuKSB7XG4gICAgICBjdXJyZW50RWxlbWVudCA9IE9ba107XG4gICAgICBpZiAoc2VhcmNoRWxlbWVudCA9PT0gY3VycmVudEVsZW1lbnQgfHxcbiAgICAgICAgKHNlYXJjaEVsZW1lbnQgIT09IHNlYXJjaEVsZW1lbnQgJiYgY3VycmVudEVsZW1lbnQgIT09IGN1cnJlbnRFbGVtZW50KSkgeyAvLyBOYU4gIT09IE5hTlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGsrKztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxuLypcblVTQUdFJkVYQU1QTEVTOiBcblRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhIGdyYW1tYXIgb2JqZWN0LCBhbmQgYSBzdHJpbmcgdG8gcGFyc2UuIEdyYW1tYXIgb2JqZWN0cyBjb250YWluIHRoZSBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gcGFyc2Ugd2hpY2hldmVyIHRoZSBzdHJpbmcgY29udGFpbnMuXG5BIGdyYW1tYXIgb2JqZWN0IGlzIGEgbWFwIChhbiBhc3NvY2lhdGl2ZSBhcnJheSksIGluIHdoaWNoIGl0J3Mga2V5cyBhcmUgbGFiZWxzIGdpdmVuIGJ5IHRoZSBwcm9ncmFtbWVyIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiB0aGUgXCJncmFtbWFyXCIgbGFiZWwgd2hpY2ggaXMgdGhlIGluaXRpYWwvc3RhcnRpbmcvbWFpbiBrZXksIHRoZSB2YWx1ZXMgYXJlIHBhdHRlcm5zOlxuVGhpcyBpcyBkZWZpbmVkIGJ5IGV4cHJlc3Npb25GZWF0dXJlcyAocGFyc2VyU3RlcHBlcnMpLCBhbmQgYmVoYXZvdXIgY2FuIGJlIGNoYW5nZWQgYnkgc29cbkEgcGF0dGVybi9mZWF1dHJlIGlzIGVpdGhlciBhbiBvYmplY3QsIGEgbmF0aXZlIGFycmF5IG9yIGEgc3RyaW5nLCB0aGV5IGNhbiBiZTpcblxuPHBhdHRlcm4+OlxuZGVmOig8cGF0dGVybj5bXXw8c3RyaW5nPnx7dHlwZTpcInJlcGV0aXRpb25cIix0bzo8aW50Pixmcm9tOjxpbnQ+LHF1YW50aWZpZXI6KFwibGF6eVwifFwiZ3JlZWR5XCIpLGNoaWxkOjxwYXR0ZXJuPn18e3R5cGU6XCJvclwiLGNoaWxkOjxwYXR0ZXJuPltdfXx7dHlwZTpcIndpbGRjYXJkXCIsdmFsdWU6KHtmcm9tOjxpbnQ+LHRvOjxpbnQ+fXw8Y2hhcj4pW11bLG5lZ2F0aXZlOjxib29sZWFuPl19fHt0eXBlOlwicG9pbnRlclwiLHZhbHVlOjxzdHJpbmc+fXx7dHlwZTpcInZhclwiLGtleTo8c3RyaW5nPlssc2V0OjxwYXR0ZXJuPl19KVxuXG4gI0FuIGFycmF5IChiYXNpY2FsbHkgYSBub25jYXB0dXJpbmcgZ3JvdXApXG4gIERlc2NyaXB0aW9uOiBjb25jYW50ZW5hdGVkIHBhdHRlcm5zLCBvciBhIHByb2dyZXNzaW9uL3NlcXVlbmNlL2NvbnRpbnV1bSBvZiBwYXR0ZXJucyBcbiAgZGVmOjxwYXR0ZXJuPltdXG4gIFVzYWdlIGV4YW1wbGU6IFtwYXR0ZXJuMSxwYXR0ZXJuMl1cbiAgICp0aGV5IHdvdWxkIGJlIGRlc2NyaWJlZCBpbiBhIG5hdGl2ZSBhcnJheSBvZiA8cGF0dGVybj5zIFxuXG4gICAqdGhlIHJlc3VsdCBpcyBhbiBhcnJheSBvZiBjaGlsZHJlbiByZXN1bHRzLCBpZiBjaGlsZHJlbiBkb24ndCByZXN1bHQsIG5vIHJlc3VsdCBpcyB0aHJvd24uXG4gICBcbiAjQSByZXBldGl0aW9uL3F1YW50aWZpZXIgXG4gIERlc2NyaXB0aW9uOiBwYXR0ZXJuLCB1c2VkIGluIG9yZGVyIHRvIG1hdGNoIHJlcGVhdGVkIHNlcXVlbmNlcypcbiAgZGVmOnt0eXBlOlwicmVwZXRpdGlvblwiLHRvOjxpbnQ+LGZyb206PGludD4scXVhbnRpZmllcjooXCJsYXp5XCJ8XCJncmVlZHlcIiksY2hpbGQ6PHBhdHRlcm4+fVxuICAgKnRoZSByZXN1bHQgaXMgYW4gYXJyYXkgb2YgY2hpbGRyZW4gcmVzdWx0cywgaWYgY2hpbGRyZW4gZG9uJ3QgcmVzdWx0LCBubyByZXN1bHQgaXMgdGhyb3duLlxuICBXZWxsLCBJIGtub3cgdGhpcyBpcyBhIGJpdCBsYXp5LCBidXQgSSBoYWQgdG8gY29uc2lkZXIgdGhhdCByZXBldGl0aW9ucyBjb3VsZCByZXR1cm4gdHdvIHRvdGFsbHkgZGlmZmVyZW50IHJlc3VsdHMgZm9yIGFsdGVybmF0aW9uIHBhdHRlcm5zXG4gIFRPRE86IGluZGljYXRlIHJlc3VsdCByZXBldGl0aW9uXG4gIFxuICMoQSBjaG9pY2V8QW4gYWx0ZXJuYXRpb24pXG4gIERlc2NyaXB0aW9uOiBBbiBhbHRlcm5hdGlvbiBhbGxvd3MgdG8gbWF0Y2ggcGF0dGVybiBvciBhbm90aGVyIHBhdHRlcm4gZXhjbHVzaXZlbHlcbiAgZGVmOnt0eXBlOlwib3JcIixjaGlsZDo8cGF0dGVybj5bXX1cbiAgXG4jQSAod2lsZGNhcmQvcmFuZ2V8Y2hhcmFjdGVyIGNsYXNzKVxuICBEZXNjcmlwdGlvbjphbGxvd3MgYSBjaGFyYWN0ZXIgdG8gbWF0Y2ggdGhlIHZhbHVlcyBnaXZlblxuICBkZWY6e3R5cGU6XCJ3aWxkY2FyZFwiLHZhbHVlOih7ZnJvbTooPGludD58PGNoYXI+KSx0bzooPGludD58PGNoYXI+KX18PGNoYXI+KVtdWyxuZWdhdGl2ZTo8Ym9vbGVhbj5dfVxuICBVc2FnZSBleGFtcGxlOiB7dHlwZTpcIndpbGRjYXJkXCIsdmFsdWU6W3tmcm9tOjUsdG86N30sXCJhXCIsXCJiXCJdLG5lZ2F0aXZlOmZhbHNlfVxuICBUaGUgcmFuZ2UgcGF0dGVybiB2YWx1ZSBpcyBhbiBhcnJheSB3aGljaCBjb250YWlucyB0aGUgZGVzaXJlZCBjaGFyYWN0ZXJzIHRvIG1hdGNoLCBvciBhbiBvYmplY3QgY29udGFpbmluZyBhIGZyb20sIHRvLiBUaGUgbGF0dGVyIGlzIGEgcmFuZ2UgbWF0aGluZyB0aGUgY2hhcmFjdGVyIGNvZGVzLlxuICBcbiAgXG4jQSBwb2ludGVyXG4gIERlc2NyaXB0aW9uOiBhIHBvaW50ZXIgYWxsb3dzIHJlY3Vyc2l2ZW5lc3MsIHNvIHlvdSBjYW4gZGVmaW5lIG1hbnkga2V5IHBhdHRlcm5zIGluIGdyYW1tYXIsIGFuZCB5b3Ugc3dpdGNoIHRvIHRoZW1cbiAgZGVmOiAge3R5cGU6XCJwb2ludGVyXCIsdmFsdWU6PHN0cmluZz59XG4gIFVzYWdlIGV4YW1wbGU6IHt0eXBlOlwicG9pbnRlclwiLHZhbHVlOlwiZ3JhbW1hclwifSAvL3dvdWxkIHBvaW50IHRvIHRoZSBtYWluIGtleVxuIFxuI1ZhcmlhYmxlc1xuICBkZWY6IHt0eXBlOlwidmFyaWFibGVcIixrZXk6PHN0cmluZz5bLHZhbHVlOjxwYXR0ZXJuPl19XG4gIFVzYWdlIGV4YW1wbGU6IHt0eXBlOlwidmFyXCIsa2V5OlwieW91ciBrZXlcIixzZXQ6bm9kZX1cbiAgV2hlbiB0aGVyZSBpcyBubyBcInNldFwiIGl0IHdpbGwgYXR0ZW1wdCB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZS5cbiBcbiNBIHN0cmluZyBwYXR0ZXJuIFxuICBEZXNjcmlwdGlvbjogbWF0Y2hlcyBhIHN0cmluZyBsaXRlcmFsbHlcbiAgZGVmOjxzdHJpbmc+XG4gIHdvdWxkIGJlIGp1c3QgZGVzY3JpYmVkIGFzIGEgbm9ybWFsIHN0cmluZ1xuIFxuI0FuIGFzc2VydGlvbiAobG9va2FoZWFkKVxuIGRlZjp7dHlwZTpcImFzc2VydGlvblwiLHZhbHVlOjxwYXR0ZXJuPixbbmVnYXRpdmU6PGJvb2xlYW4+XX1cbiBUaGVzZSBhcmUgemVyby1sZW5ndGggYXNzZXJ0aW9ucyBsaWtlIGxvb2thcm91bmRzIG9yIFxcYiBpbiByZWdleCwgYmFzaWNhbGx5IGNvbmRpdGlvbmFsIGV4cHJlc3Npb25zIHRoZXNlIGFyZSBidHcgYXRvbWljXG4gXG4jQSByZXZlcnNlIHN0YXRtZW50XG4gIERlc2NyaXB0aW9uOiB3aWxsIHN0YXJ0IG1hdGNoaW5nIDxwYXR0ZXJuPiBpbiByZXZlcnNlLCB3aHkgd291bGQgeW91IGRvIHRoaXM/IERvZXNuJ3QgcmV2ZXJzZSBvcmRlciBvZiBzdHJpbmdzLCBzbyB0aGlzIHdpbGwgY29uZnVzZSB5b3UgOilcbiAgZGVmOnt0eXBlOlwicmV2ZXJzZVwiLHZhbHVlOjxwYXR0ZXJuPn1cbiAgVXNhZ2UgZXhhbXBsZTp7dHlwZTpcInJldmVyc2VcIix2YWx1ZTpbXCJhYlwiLFwidGFcIl19Ly93aWxsIG9ubHkgbWF0Y2ggdGFhYlxuICBOb3JtYWxseSBtYXRjaGVzIGFyZSBSVEwgYnV0IGlmIHlvdSB3YW50IHRvIG1hdGNoIGl0IExUUiB0aGF0IGlzIGZpbmUgdG9vLCBwbGVhc2UgY29uc2lkZXIgdGhhdCB0aGlzIHdpbGwganVzdCByZXZlcnNlIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGN1cnNvciwgbGl0ZXJhbCBzdHJpbmdzIHNob3VsZCB3b3JrIFJUTCBqdXN0IGFzIGZpbmUsIGJ1dCBhcnJheXMgYW5kIG90aGVyIG9yYmplY3RzIHdpbGwgYmUgcmVhZCBhcyBnaXZlblxuICAoTmVzdGVkIHJldmVyc2VzIHdpbGwgbWF0Y2ggYWdhaW4gUlRMKVxuICBcbiNBbiBhdG9taWMgbm9kZVxuICBEZXNjcmlwdGlvbjogbWFrZXMgYSBwYXR0ZXJuIGF0b21pYywgQXRvbWljIG5vZGVzIHdvdWxkIGRpc2FsbG93IGJha2N0cmFja2luZyB3aGVuIGl0IGRvZXMgcmV0dXJuLlxuICBkZWY6IHt0eXBlOlwiYXRvbWljXCIsdmFsdWU6PHBhdHRlcm4+fSBcbiAgXG4gXG5Ob3RlIHRoYXQgcmVnZXggL2E/LyB3b3VsZCBiZSBkZXNjcmliZWQgYXMgYSBxdWFudGlmaWVyIHBhdHRlcm4sIGxpa2UgL2F7MCwxfS9cbmZvciBleGFtcGxlLCB0aGUgcGF0dGVybiBbXCJodW1hblwiLHt0eXBlOlwicmVwZXRpdGlvblwiLHRvOjAsZnJvbToxLGNoaWxkOlwic1wifV0gd291bGQgbWF0Y2ggXCJodW1hblwiIGFuZCBcImh1bWFuc1wiXG5JdCdzIG5vdCBpbnRlbmRlZCBmb3IgYSBwcm9ncmFtbWVyIHRvIHdyaXRlIHRoZSBwYXR0ZXJuIHRoZW1zZWx2ZXMsIHNpbmNlIHRoZXkncmUgbW9zdGx5IGEgdHJhbnNsYXRpb24gb2YgcmVnZXguIGEgcmVwcmVzZW50YXRpb24gb2YgZW1cbipBbHJpZ2h0IGJ1dCBiZWZvcmUgd2UgY29udGludWUsIHdlIG11c3QgZmlyc3QgbWVudGlvbiAyIHBhdHRlcm5zIHRoYXQgY2FuIGFjdHVhbGx5IGNoYW5nZSBpdHMgY29udGVudCwgdGhvc2UgYXJlIGFsdGVybmF0aW9ucyBhbmQgcXVhbnRpZmllcnMuXG5iZWNhdXNlIGFsdGVybmF0aW9ucyBhbmQgcXVhbnRpZmllcnMgY2FuIG1hdGNoIGJlZm9yZSBhbGwgdGhlaXIgcG9zc2liaWxpdGllcyBhcmUgdGVzdGVkLCB3ZSBuZWVkIGEgd2F5IGZvciB0aGVtIHRvIHN0b3JlIHRoZWlyIHN0YXRlLlxuXG5BIHJlc3RvcmUgdHJpZ2dlcnMgd2hlbiBwYXJlbnQgZXhwcmVzc2lvbiBpbmRleE9mIGlzIGxlc3NlciB0aGFuIHdoZXJlIHJlc3RvcmUgaXMgZnJvbS5cbiovXG5cbi8vU28sIHRoaXMgbG9uZyBleHBlY3RlZCBcInJlYWRlci1tYWNybyBiZWdpbnNcIlxudmFyIGFzZGY9W11cbmZ1bmN0aW9uIHBhcnNlKHBhcnNlclN0ZXBwZXJzLCBncmFtbWFyLCB0ZXh0VG9QYXJzZSwgcGFyc2VDb250ZXh0LCBmaW5hbCwgdGltZU91dCkgeyAvL2Z1bmN0aW9uIHN0YXJ0XG4gIC8qU2luY2UgY29kaW5nIHRoaXMgaXMgdGFraW5nIHdheSBsb25nZXIgdGhhbiB1c3VhbCwgSSdkIGJldHRlciB3cml0ZSB0aGUgc3BlY2lmaWNhdGlvbnMgb2YgdGhpcyBmdW5jdGlvbi5cbiAgVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGdyYW1tYXIsIGEgc3RyaW5nIGFuZCBhIHBhcnNlQ29udGV4dCwgaXQgcmV0dXJucyBhIHBhcnNlQ29udGV4dC4gVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgYWJsZSB0byByZXR1cm4gcGFyc2luZyBjb250ZXh0cyBmb3IgaW5jb21wbGV0ZSBzdHJpbmdzIG9mIGRhdGEuIEl0IHRha2VzIGEgcGFyc2VDb250ZXh0IGlmIHRoaXMgZnVuY3Rpb24gaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSBhbmQgaXQgcmV0YWtlcyB0aGUgam9iIGZyb20gdGhlcmUuXG4gIFRoZSBncmFtbWFyIGlzIHNwZWNpZmllZCBpbiBhbiBvYmplY3QsIHRoZSBydWxlcyBhcmUgYWJvdmUgdGhpcyBmdW5jdGlvbi5cbiAgdGV4dFRvUGFyc2UgaXMgb2YgdHlwZSBzdHJpbmcsIGl0J3MgdGhlIHN0cmluZyBhYm91dCB0byBiZSBwYXJzZWRcbiAgcGFyc2VDb250ZXh0LCBpcyBudWxsLCBpdHMgb25seSB1c2VkIHdoZW4gdGV4dFRvUGFyc2Ugd2FzIFwiaW5jb21wbGV0ZVwiIGxhc3QgdGltZSwgYW5kIG5vdyB0aGVyZSdzIG1vcmUgaW5mb3JtYXRpb24gaW4gb3JkZXIgdG8gZmluaXNoIHBhcnNpbmdcbiAgZmluYWwsIGRlZmF1bHQgdG8gdHJ1ZSwgaWYgZmFsc2UgaXQgbWVhbnMgdGhhdCB0aGUgdGV4dFRvUGFyc2UgaXMgbm90IGNvbXBsZXRlLCBhbmQgaXQgd2lsbCBqdXN0IGF0dGVtcHQgdG8gcGFyc2Ugd2hhdCBpdCBjYW4gd2l0aCB3aGF0IGl0IGhhcywgaXQgd2lsbCBoYWx0IHdoZW4gaXQgY2Fubm90IHJlYWQgbW9yZVxuICAqL1xuICAvKiovXG4gIC8vU3RlcCBjb25zdHJ1Y3RvclxuICBmdW5jdGlvbiBTdGVwKGNvbnRleHQsIGluZGV4KSB7XG4gICAgaWYgKCEoY29udGV4dCBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpKSB7IHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5pbmRleE9mID0gaW5kZXg7XG4gICAgdGhpcy5zdGFydEluZGV4T2YgPSBpbmRleDtcbiAgICB0aGlzLnJlc3VsdCA9IG51bGwgfWVsc2V7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsY29udGV4dClcbiAgICAgIHRoaXMucmVzdWx0PXRoaXMucmVzdWx0JiZ0aGlzLnJlc3VsdC5zbGljZSgwKVxuICAgICAgaWYodGhpcy5tYXRjaGVzKXRoaXMubWF0Y2hlcz10aGlzLm1hdGNoZXMuc2xpY2UoMClcbiAgICB9XG4gICAgdGhpcy5yZXN0b3JlID0gcGFyc2VDb250ZXh0LnJlc3RvcmU7XG4gICAgdGhpcy5yZXZlcnNlID0gcGFyc2VDb250ZXh0LnJldmVyc2U7XG4gICAgLy9pZighdGhpcy5jb250ZXh0KXt0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRleHQgZ2l2ZW4hJyl9XG4gIH0vL1RoaXMgbXVzdCBiZSB3cm9uZywgZm9yZ2l2ZSBtZVxuICAgIFN0ZXAucHJvdG90eXBlLmdyYW1tYXJLZXkgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiBncmFtbWFyW3ZhbF1cbiAgICB9XG4gICAgU3RlcC5wcm90b3R5cGUudmFyaWFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBwYXJzZUNvbnRleHQudmFyaWFibGVzXG4gICAgfVxuICAgIFN0ZXAucHJvdG90eXBlLmlzRmluYWw9ZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmaW5hbDtcbiAgICB9XG4gICAgaWYoZmluYWw9PT12b2lkIDApZmluYWw9dHJ1ZTtcbiAgaWYgKCFwYXJzZUNvbnRleHQpIHsgLy9pZiB0aGVyZSBpcyBubyBwYXJzZUNvbnRleHQsIGNyZWF0ZSBvbmVcbiAgICBwYXJzZUNvbnRleHQgPSB7IGluZGV4T2Y6IDAsIGZhaWw6IGZhbHNlLCByZXN0b3JlOiAwLCByZXN1bHQ6IG51bGwsIHZhcmlhYmxlczp7fSxyZXZlcnNlOmZhbHNlIH07XG4gICAgLy9BIHJlc3RvcmUgdmFsdWUgaXMgYSBtYXAgdGhhdCBjb250YWlucyAzIGVsZW1lbnRzXG4gICAgcGFyc2VDb250ZXh0LnJvb3Q9bmV3IFRyZWUoXCJyb290XCIpXG4gICAgcGFyc2VDb250ZXh0LnN0ZXBJbmZvID0gcGFyc2VDb250ZXh0LnJvb3QuYWRkQ2hpbGQobmV3IFN0ZXAoZ3JhbW1hci5ncmFtbWFyLCAwKSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RlcEluUHJvY2VkdXJlKGNvbnRleHQpIHtcbiAgICB2YXIgc3RhcnRJbmRleE9mID0gcGFyc2VDb250ZXh0LnN0ZXBJbmZvLmRhdGEuaW5kZXhPZjtcbiAgICBwYXJzZUNvbnRleHQuc3RlcEluZm8gPSBwYXJzZUNvbnRleHQuc3RlcEluZm8uYWRkQ2hpbGQobmV3IFN0ZXAoY29udGV4dCwgc3RhcnRJbmRleE9mKSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RlcE91dFByb2NlZHVyZShmKSB7XG4gICAgLy9mdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBmdW5jdGlvbiBoYXMgY2hlY2tlZCBhbmQgaXQgd2FzIHRvIGNvbnRpbnVlIHRvIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgIC8vZiBpcyBhIGJvb2xlYW4gdmFsdWUgc2F5aW5nIHRoZSBtYXRjaCBmYWlsIGlzIHRydWUsIGlmIGlmIGlzIHRydWUsIHRoZSBtYXRjaCBmYWlsZWRcbiAgICAvL2Z1biBmYWN0OiBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgaXQgd2lsbCBidWJibGUgdXAgdW50aWwgaXQgZmluZHMgYSBsb3dlciByZXN0b3JhYmxlIHZhbHVlIGFuZCB0aGVuIGJ1YmJsZSBkb3duXG4gICAgXG4gICAgdmFyIGNoaWxkU3RlcCA9IHBhcnNlQ29udGV4dC5zdGVwSW5mbywgY2hpbGREYXRhID0gY2hpbGRTdGVwLmRhdGEsIHM7XG4gICAgcGFyc2VDb250ZXh0LnN0ZXBJbmZvID0gcGFyc2VDb250ZXh0LnN0ZXBJbmZvLnBhcmVudDtcbiAgICBcbiAgICAgIGlmIChmJiYocz1jaGlsZFN0ZXAucHJldmlvdXNTaWJsaW5nKCkpKSB7XG4gICAgICAgIC8vSWYgZnVuY3Rpb24gZmFpbGVkIGJ1dCBpdCBoYXMgYSBzaWJsaW5nLCByZXN0b3JlIHRoYXQgc2libGluZ1xuICAgICAgcGFyc2VDb250ZXh0LnJlc3RvcmUtLTtcbiAgICAgIGNoaWxkU3RlcC5kZXRhY2hGcm9tUGFyZW50KClcbiAgICAgIHdoaWxlKHM9cy5nZXRMYXN0Q2hpbGQoKSl7XG4gICAgICAgIHBhcnNlQ29udGV4dC5zdGVwSW5mbz1zXG4gICAgICB9XG4gICAgICBwYXJzZUNvbnRleHQuc3RlcEluZm8uY2hpbGRTdGVwPW51bGxcbiAgICAgIHBhcnNlQ29udGV4dC5zdGVwSW5mby5kYXRhLnJlc3RvcmVkPXRydWU7XG4gICAgICByZXR1cm47XG4gICAgfSBcbiAgICBpZihwYXJzZUNvbnRleHQuc3RlcEluZm8uZGF0YT09XCJyb290XCIpe1xuICAgICAgICBjaGlsZERhdGEuZmFpbCA9IGZcbiAgICAgICAgcmV0dXJufVxuICAgIGlmIChjaGlsZERhdGEucmVzdG9yZSA9PT0gcGFyc2VDb250ZXh0LnJlc3RvcmUpIHtcbiAgICAgIGNoaWxkU3RlcC5kZXRhY2hGcm9tUGFyZW50KClcbiAgICAgIC8qaWYocGFyc2VDb250ZXh0LnN0ZXBJbmZvLmRhdGEucmVzdG9yZSE9PSBwYXJzZUNvbnRleHQucmVzdG9yZSl7XG4gICAgICAgIHBhcnNlQ29udGV4dC5zdGVwSW5mbz1wYXJzZUNvbnRleHQuc3RlcEluZm8ucGFyZW50LmFkZENoaWxkKG5ldyBTdGVwKHBhcnNlQ29udGV4dC5zdGVwSW5mby5kYXRhKSlcbiAgICAgICAgfSovXG4gICAgfS8vZWxzZVxuICAgICAgIGlmKHBhcnNlQ29udGV4dC5zdGVwSW5mby5kYXRhLnJlc3RvcmUhPT0gcGFyc2VDb250ZXh0LnJlc3RvcmUpe1xuICAgICAgcGFyc2VDb250ZXh0LnN0ZXBJbmZvPXBhcnNlQ29udGV4dC5zdGVwSW5mby5wYXJlbnQuYWRkQ2hpbGQobmV3IFN0ZXAocGFyc2VDb250ZXh0LnN0ZXBJbmZvLmRhdGEpKVxuICAgICAgICBcbiAgICAgIH1cbiAgICAgIC8qZWxzZSB7cGFyc2VDb250ZXh0LnN0ZXBJbmZvPW5ldyBTdGVwKHBhcnNlQ29udGV4dC5zdGVwSW5mby5kYXRhKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd2FpdCwgbm8gcGFyZW50Pz8nKTtcbiAgICAgIH0qL1xuICAgIFxuICAgIHBhcnNlQ29udGV4dC5zdGVwSW5mby5kYXRhLmNoaWxkU3RlcCA9IGNoaWxkRGF0YVxuICAgIC8vVEhJUyBTSE9VTEQgQkUgU09NRSBLSU5EIE9GIFBBUkVOVCBGTEFHXG4gICAgY2hpbGREYXRhLmZhaWwgPSBmXG4gICAgLy9OT09PT08gcGFyc2VDb250ZXh0LnN0ZXBJbmZvLmRhdGEuaW5kZXhPZiA9IGNoaWxkRGF0YS5pbmRleE9mO1xuICAgIHJldHVybjtcbiAgfVxuICBtYWlubG9vcDogLy9iZWdpbnMgbG9vcGluZyBvdmVyIGdyYW1tYXIgb2JqZWN0XG4gICAgZG8ge1xuLy9jb25zb2xlLmxvZygnZXhlY3V0ZWQgbWFpbmxvb3AnKTtcbiAgICAgIHZhciBtYXRjaCA9IHBhcnNlQ29udGV4dC5zdGVwSW5mby5kYXRhLFxuICAgICAgICB0eXBlID0gZ2V0VHlwZShtYXRjaC5jb250ZXh0KTtcbiAgICAgIHZhciBzdGVwcGVyID0gcGFyc2VyU3RlcHBlcnNbdHlwZV0sXG4gICAgICAgIG5leHRQYXJzZUluc3RydWN0aW9uO1xuICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgc3RlcHBlciA9IHN0ZXBwZXJbbWF0Y2guY29udGV4dC50eXBlXTtcbiAgICAgIH1cbiAgICAgIC8vY29vbFRyZWU9KGZ1bmN0aW9uKCl7dmFyIHBwYXBhPVwiXCI7cGFyc2VDb250ZXh0LnJvb3QuZm9yRWFjaChmdW5jdGlvbihpLGlpKXsgICAgdmFyIHQ9Z2V0VHlwZShpLmRhdGEuY29udGV4dCk7ICAgIGlmKGkuZGF0YT09XCJyb290XCIpe3Q9XCJyb290XCJ9ZWxzZSBpZih0PT1cIm9iamVjdFwiKXsgICAgICAgIHQ9aS5kYXRhLmNvbnRleHQudHlwZTsgICAgfSAgICBpLnN0cmluZz1paStcIixcIitpLmRhdGEucmVzdG9yZStcIjogXCIrdCsodD09XCJhcnJheVwiP1wiIGxlbmd0aDpcIitpLmRhdGEuY29udGV4dC5sZW5ndGgrXCIgaXRlcmF0b3I6XCIraS5kYXRhLml0ZXJhdG9yOlwiXCIpKyh0PT1cIm9yXCI/XCIgY2hvaWNlczpcIitpLmRhdGEuY29udGV4dC5jaG9pY2VzLmxlbmd0aCtcIiBpdGVyYXRvcjpcIitpLmRhdGEuaXRlcmF0b3I6XCJcIikrKHQ9PVwic3RyaW5nXCI/XCI6XCIraS5kYXRhLmNvbnRleHQ6XCJcIikrKHQ9PVwicG9pbnRlclwiP1wiOlwiK2kuZGF0YS5jb250ZXh0LnZhbHVlOlwiXCIpKyh0PT1cInJlcGV0aXRpb25cIj9cIiwgcmVwczpcIisoaS5kYXRhLm1hdGNoZXMmJmkuZGF0YS5tYXRjaGVzLmxlbmd0aCkrXCIgXCIraS5kYXRhLmNvbnRleHQucXVhbnRpZmllcjpcIlwiKTsgICAgaWYoaS5wYXJlbnQmJmkucGFyZW50LnN0cmluZykgIHBwYXBhKz1KU09OLnN0cmluZ2lmeShpLnBhcmVudC5zdHJpbmcpK1wiLT5cIitKU09OLnN0cmluZ2lmeShpLnN0cmluZykrXCI7XFxuXCI7fSk7cmV0dXJuIHBwYXBhfSlcbiAgICAgIGZ1bmN0aW9uIGdldFJlc3VsdCh2KXtpZighdil7cmV0dXJuIG51bGx9dmFyIG09W107bS5wdXNoKHYuZGF0YS5yZXN1bHQpO2lmKHYuY2hpbGRyZW4pe209bS5jb25jYXQoZ2V0UmVzdWx0KHYuY2hpbGRyZW5bdi5jaGlsZHJlbi5sZW5ndGgtMV0pKX07cmV0dXJuIG19XG4gICAgICBjb29sVHJlZTI9KGZ1bmN0aW9uKCl7XG52YXIgcHBhcGE9XCJcIjtwYXJzZUNvbnRleHQucm9vdC5mb3JFYWNoKGZ1bmN0aW9uKGksaWkpe1xuICAgIFxuICAgIHZhciB0PWdldFR5cGUoaS5kYXRhLmNvbnRleHQpXG4gICAgaWYoaS5kYXRhPT1cInJvb3RcIil7dD1cInJvb3RcIn1lbHNlIGlmKHQ9PVwib2JqZWN0XCIpe1xuICAgICAgICB0PWkuZGF0YS5jb250ZXh0LnR5cGVcbiAgICB9XG4gICAgaS5zdHJpbmc9aS5kYXRhLnJlc3RvcmUrXCI6IFwiK3QrKHQ9PVwiYXJyYXlcIj9cIiBsZW5ndGg6XCIraS5kYXRhLmNvbnRleHQubGVuZ3RoK1wiIGl0ZXJhdG9yOlwiK2kuZGF0YS5pdGVyYXRvcjpcIlwiKSsodD09XCJvclwiP1wiIGNob2ljZXM6XCIraS5kYXRhLmNvbnRleHQuY2hvaWNlcy5sZW5ndGgrXCIgaXRlcmF0b3I6XCIraS5kYXRhLml0ZXJhdG9yOlwiXCIpKyh0PT1cInN0cmluZ1wiP1wiOlwiK2kuZGF0YS5jb250ZXh0OlwiXCIpKyh0PT1cInBvaW50ZXJcIj9cIjpcIitpLmRhdGEuY29udGV4dC52YWx1ZTpcIlwiKSsodD09XCJyZXBldGl0aW9uXCI/XCIsIHJlcHM6XCIrKGkuZGF0YS5tYXRjaGVzJiZpLmRhdGEubWF0Y2hlcy5sZW5ndGgpK1wiIFwiK2kuZGF0YS5jb250ZXh0LnF1YW50aWZpZXI6XCJcIik7XG4gICAgXG4gICAgcHBhcGErPUFycmF5LmFwcGx5KHRoaXMsQXJyYXkoaWkpKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gXCLilIIgICBcIn0pLmpvaW4oJycpK1wi4pScXCIrSlNPTi5zdHJpbmdpZnkoaS5zdHJpbmcpK1wiXFxuXCJcbn0pO3JldHVybiBcIlJvbGxiYWNrdHJlZTpcIitwcGFwYStcIlxcbkxhc3RSZXN1bHQ6XCIrZ2V0UmVzdWx0KHBhcnNlQ29udGV4dC5yb290KS5qb2luKCl9KVxuXG5cblxuICAgICAgaWYobWF0Y2guaW5kZXhPZj50ZXh0VG9QYXJzZS5sZW5ndGgpe1xuICAgICAgICAvL3doeSB3b3VsZCB0aGUgaW5kZXhPZiBiZSBiaWdnZXIgdGhhbiB0aGUgdGV4dFRvUGFyc2U/ICBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIGl0IG1lYW5zIHRoZSBtZXRob2QgYmVmb3JlIGhhcyBhZGRlZCB0b28gbWFueSBlbGVtZW50cyB0byBpbmRleE9mIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSB0ZXh0IHRoYXQgbXVzdCBiZSBwYXJzZWQnKVxuICAgICAgfVxuZGVidWdnZXI7XG4gICAgICBuZXh0UGFyc2VJbnN0cnVjdGlvbiA9IHN0ZXBwZXIobWF0Y2gsIHRleHRUb1BhcnNlKTtcbiAgICAgIHBhcnNlQ29udGV4dC5yZXZlcnNlPW1hdGNoLnJldmVyc2U7XG4gICAgICBpZiAodHlwZSA9PT0gXCJvYmplY3RcIiYmcGFyc2VyU3RlcHBlcnMubWV0YS5yZXN0b3JhYmxlLmluY2x1ZGVzKG1hdGNoLmNvbnRleHQudHlwZSkpIHtcbiAgICAgICAgaWYgKG5leHRQYXJzZUluc3RydWN0aW9uWzBdID09PSBwYXJzZS5TVEVQX09VVCkgeyBuZXh0UGFyc2VJbnN0cnVjdGlvblswXSA9IHBhcnNlLlNhdmVTdGF0ZU91dCB9XG4gICAgICB9XG4gICAgICAvL2RpZmZlcmVudCBpbnN0cnVjdGlvbnMhXG4gICAgICBzd2l0Y2ggKG5leHRQYXJzZUluc3RydWN0aW9uWzBdKSB7XG4gICAgICAgIGNhc2UgcGFyc2UuVEhST1c6XG4gICAgICAgICAgaWYocGFyc2UudmVyYm9zZSljb25zb2xlLmVycm9yKG5leHRQYXJzZUluc3RydWN0aW9uWzFdKVxuICAgICAgICAgIG1hdGNoLmZhaWxNc2c9bmV4dFBhcnNlSW5zdHJ1Y3Rpb25bMV1cbiAgICAgICAgICBzdGVwT3V0UHJvY2VkdXJlKHRydWUsIG1hdGNoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBwYXJzZS5TVEVQX0lOOlxuICAgICAgICAgIGlmKCFuZXh0UGFyc2VJbnN0cnVjdGlvblsxXSl7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGVwIHJlcXVlc3RlZCBhIHN0ZXAgaW4gYnV0IG5vIGRlY2xhcmVkIGluc3RydWN0aW9uIHRvIHN0ZXAgaW50by5cIilcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RlcEluUHJvY2VkdXJlKG5leHRQYXJzZUluc3RydWN0aW9uWzFdKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBwYXJzZS5TYXZlU3RhdGVPdXQ6XG4gICAgICAgICAgcGFyc2VDb250ZXh0LnJlc3RvcmUrKztcbiAgICAgICAgICAvL3BhcnNlQ29udGV4dC5yZXN0b3JlID0gcGFyc2VDb250ZXh0LnJlc3RvcmUucGFyZW50O1xuICAgICAgICBjYXNlIHBhcnNlLlNURVBfT1VUOlxuICAgICAgICAgIHN0ZXBPdXRQcm9jZWR1cmUoZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHBhcnNlLkhBTFQ6XG4gICAgICAgICAgaWYocGFyc2UudmVyYm9zZSljb25zb2xlLmxvZyhcInBhcnNlciBoYWx0ZWRcIilcbiAgICAgICAgICBwYXJzZUNvbnRleHQuaGFsdGVkPXRydWU7XG4gICAgICAgICAgYnJlYWsgbWFpbmxvb3A7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9IHdoaWxlIChwYXJzZUNvbnRleHQuc3RlcEluZm8uZGF0YSE9PVwicm9vdFwiKTtcbiAgICBwYXJzZUNvbnRleHQucmVzdWx0PXBhcnNlQ29udGV4dC5yb290LmdldExhc3RDaGlsZCgpLmRhdGEucmVzdWx0XG4gICAgcGFyc2VDb250ZXh0LmZhaWw9ISFwYXJzZUNvbnRleHQucm9vdC5nZXRMYXN0Q2hpbGQoKS5kYXRhLmZhaWxcbiAgICBwYXJzZUNvbnRleHQuaW5kZXhPZj1wYXJzZUNvbnRleHQucm9vdC5nZXRMYXN0Q2hpbGQoKS5kYXRhLmluZGV4T2ZcbiAgICBpZighcGFyc2VDb250ZXh0LmZhaWwmJihmaW5hbHx8IXBhcnNlQ29udGV4dC5oYWx0ZWQpKXBhcnNlQ29udGV4dC5mYWlsPXBhcnNlQ29udGV4dC5pbmRleE9mIT09dGV4dFRvUGFyc2UubGVuZ3RoXG4gICAgcmV0dXJuIHBhcnNlQ29udGV4dDtcbn1cblxuT2JqZWN0LmFzc2lnbihwYXJzZSxyZXF1aXJlKCcuL3BhcnNlci1jb25zdGFudHMuanMnKSlcbm1vZHVsZS5leHBvcnRzPXBhcnNlO1xuXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./parser.js\n");

/***/ }),

/***/ "./regex-rules.js":
/*!************************!*\
  !*** ./regex-rules.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var metachars = [\"[\", \"(\", \")\", \"+\", \"?\", \".\", \"*\"]\nvar regexGrammar = {\n  regex: [{ type: \"repetition\", to: 1, from: 0, quantifier: \"greedy\", child: \"^\" },{ type: \"repetition\", to: Infinity, from: 0, quantifier: \"lazy\", child: { type: \"or\", choices: [{ type: \"pointer\", value: \"group\" }, { type: \"pointer\", value: \"wildcard\" }, { type: \"pointer\", value: \"escape\" }, { type: \"pointer\", value: \"special\" }, wildcardToken(\"Anything\")] } }, { type: \"repetition\", to: 1, from: 0, quantifier: \"greedy\", child: \"$\" }],\n  wildcard: [\"[\", {\n    type: \"repetition\",\n    to: Infinity,\n    from: 0,\n    quantifier: \"greedy\",\n    child: {\n      type: \"or\",\n      child: [{ type: \"pointer\", value: \"escape\" },\n        [{ type: \"wildcard\", value: [\"]\"], negative: true }, { type: \"repetition\", to: 1, from: 0, quantifier: \"greedy\", child: ['-', [{ type: \"wildcard\", value: [\"]\"], negative: true }]] }]\n      ]\n    }\n  }, \"]\"],\n  group: ['(', { type: \"repetition\", to: 1, from: 0, quantifier: \"greedy\", child: { type: \"pointer\", value: \"groupTypes\" } }, ')'],\n  grammar: ['/', { type: \"pointer\", value: \"regex\" }, '/', { type: \"pointer\", value: \"flags\" }],\n  escape: [\"\\\\\", wildcardToken(\"Anything\")],\n  special: { type: \"or\", choices: [\"{\", { type: \"repetition\", from: 1, to: Infinity, quantifier: \"lazy\", child: wildcardToken(\"Digit\") }] },\n  groupTypes: {},\n  flags:{type:\"repetition\",from:0,to:5,quantifier:\"greedy\",child:[{type:\"variable\",key:\"wildcardvalue\",value:{type:\"wildcard\",value:[\"i\",\"m\",\"g\",\"u\",\"y\"]}},{type:\"assertion\",look:\"ahead\",negative:true,value:[{type:\"repetition\",from:0,to:5,quantifier:\"lazy\",child:{type:\"wildcard\",value:[\"i\",\"m\",\"g\",\"u\",\"y\"]}},{type:\"variable\",key:\"wildcardvalue\"}]}]}\n};\nfunction wildcardToken(type, negative) {\n  negative = negative | false;\n  switch (type) {\n    case \"Anything\":\n      return { type: \"wildcard\", value: [{ from: 0, to: Infinity }], negative: negative };\n      break;\n    case \"Digit\":\n      return { type: \"wildcard\", value: [{ from: 0x30, to: 0x39 }], negative: negative };\n      break;\n    case \"Whitespace\":\n      return { type: \"wildcard\", value: [{ from: \"\\u0009\", to: \"\\u000D\" }, \" \", \"\", \" \", \" \", { from: \"\", to: \"‍\" }, \" \", \" \", \"　\", \"᠎\", \"⁠\", \"﻿\"], negative: negative };\n      break;\n    default:\n      if (/[\\s\\S]-[\\s\\S]/.test(type)) {\n        return { type: \"wildcard\", value: [{ from: type[0], to: type[2] }], negative: negative };\n      }\n      break;\n  }\n}\nmodule.exports=regexGrammar;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZWdleC1ydWxlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3JlZ2V4LXJ1bGVzLmpzP2Q4MDMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG1ldGFjaGFycyA9IFtcIltcIiwgXCIoXCIsIFwiKVwiLCBcIitcIiwgXCI/XCIsIFwiLlwiLCBcIipcIl1cbnZhciByZWdleEdyYW1tYXIgPSB7XG4gIHJlZ2V4OiBbeyB0eXBlOiBcInJlcGV0aXRpb25cIiwgdG86IDEsIGZyb206IDAsIHF1YW50aWZpZXI6IFwiZ3JlZWR5XCIsIGNoaWxkOiBcIl5cIiB9LHsgdHlwZTogXCJyZXBldGl0aW9uXCIsIHRvOiBJbmZpbml0eSwgZnJvbTogMCwgcXVhbnRpZmllcjogXCJsYXp5XCIsIGNoaWxkOiB7IHR5cGU6IFwib3JcIiwgY2hvaWNlczogW3sgdHlwZTogXCJwb2ludGVyXCIsIHZhbHVlOiBcImdyb3VwXCIgfSwgeyB0eXBlOiBcInBvaW50ZXJcIiwgdmFsdWU6IFwid2lsZGNhcmRcIiB9LCB7IHR5cGU6IFwicG9pbnRlclwiLCB2YWx1ZTogXCJlc2NhcGVcIiB9LCB7IHR5cGU6IFwicG9pbnRlclwiLCB2YWx1ZTogXCJzcGVjaWFsXCIgfSwgd2lsZGNhcmRUb2tlbihcIkFueXRoaW5nXCIpXSB9IH0sIHsgdHlwZTogXCJyZXBldGl0aW9uXCIsIHRvOiAxLCBmcm9tOiAwLCBxdWFudGlmaWVyOiBcImdyZWVkeVwiLCBjaGlsZDogXCIkXCIgfV0sXG4gIHdpbGRjYXJkOiBbXCJbXCIsIHtcbiAgICB0eXBlOiBcInJlcGV0aXRpb25cIixcbiAgICB0bzogSW5maW5pdHksXG4gICAgZnJvbTogMCxcbiAgICBxdWFudGlmaWVyOiBcImdyZWVkeVwiLFxuICAgIGNoaWxkOiB7XG4gICAgICB0eXBlOiBcIm9yXCIsXG4gICAgICBjaGlsZDogW3sgdHlwZTogXCJwb2ludGVyXCIsIHZhbHVlOiBcImVzY2FwZVwiIH0sXG4gICAgICAgIFt7IHR5cGU6IFwid2lsZGNhcmRcIiwgdmFsdWU6IFtcIl1cIl0sIG5lZ2F0aXZlOiB0cnVlIH0sIHsgdHlwZTogXCJyZXBldGl0aW9uXCIsIHRvOiAxLCBmcm9tOiAwLCBxdWFudGlmaWVyOiBcImdyZWVkeVwiLCBjaGlsZDogWyctJywgW3sgdHlwZTogXCJ3aWxkY2FyZFwiLCB2YWx1ZTogW1wiXVwiXSwgbmVnYXRpdmU6IHRydWUgfV1dIH1dXG4gICAgICBdXG4gICAgfVxuICB9LCBcIl1cIl0sXG4gIGdyb3VwOiBbJygnLCB7IHR5cGU6IFwicmVwZXRpdGlvblwiLCB0bzogMSwgZnJvbTogMCwgcXVhbnRpZmllcjogXCJncmVlZHlcIiwgY2hpbGQ6IHsgdHlwZTogXCJwb2ludGVyXCIsIHZhbHVlOiBcImdyb3VwVHlwZXNcIiB9IH0sICcpJ10sXG4gIGdyYW1tYXI6IFsnLycsIHsgdHlwZTogXCJwb2ludGVyXCIsIHZhbHVlOiBcInJlZ2V4XCIgfSwgJy8nLCB7IHR5cGU6IFwicG9pbnRlclwiLCB2YWx1ZTogXCJmbGFnc1wiIH1dLFxuICBlc2NhcGU6IFtcIlxcXFxcIiwgd2lsZGNhcmRUb2tlbihcIkFueXRoaW5nXCIpXSxcbiAgc3BlY2lhbDogeyB0eXBlOiBcIm9yXCIsIGNob2ljZXM6IFtcIntcIiwgeyB0eXBlOiBcInJlcGV0aXRpb25cIiwgZnJvbTogMSwgdG86IEluZmluaXR5LCBxdWFudGlmaWVyOiBcImxhenlcIiwgY2hpbGQ6IHdpbGRjYXJkVG9rZW4oXCJEaWdpdFwiKSB9XSB9LFxuICBncm91cFR5cGVzOiB7fSxcbiAgZmxhZ3M6e3R5cGU6XCJyZXBldGl0aW9uXCIsZnJvbTowLHRvOjUscXVhbnRpZmllcjpcImdyZWVkeVwiLGNoaWxkOlt7dHlwZTpcInZhcmlhYmxlXCIsa2V5Olwid2lsZGNhcmR2YWx1ZVwiLHZhbHVlOnt0eXBlOlwid2lsZGNhcmRcIix2YWx1ZTpbXCJpXCIsXCJtXCIsXCJnXCIsXCJ1XCIsXCJ5XCJdfX0se3R5cGU6XCJhc3NlcnRpb25cIixsb29rOlwiYWhlYWRcIixuZWdhdGl2ZTp0cnVlLHZhbHVlOlt7dHlwZTpcInJlcGV0aXRpb25cIixmcm9tOjAsdG86NSxxdWFudGlmaWVyOlwibGF6eVwiLGNoaWxkOnt0eXBlOlwid2lsZGNhcmRcIix2YWx1ZTpbXCJpXCIsXCJtXCIsXCJnXCIsXCJ1XCIsXCJ5XCJdfX0se3R5cGU6XCJ2YXJpYWJsZVwiLGtleTpcIndpbGRjYXJkdmFsdWVcIn1dfV19XG59O1xuZnVuY3Rpb24gd2lsZGNhcmRUb2tlbih0eXBlLCBuZWdhdGl2ZSkge1xuICBuZWdhdGl2ZSA9IG5lZ2F0aXZlIHwgZmFsc2U7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJBbnl0aGluZ1wiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ3aWxkY2FyZFwiLCB2YWx1ZTogW3sgZnJvbTogMCwgdG86IEluZmluaXR5IH1dLCBuZWdhdGl2ZTogbmVnYXRpdmUgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJEaWdpdFwiOlxuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ3aWxkY2FyZFwiLCB2YWx1ZTogW3sgZnJvbTogMHgzMCwgdG86IDB4MzkgfV0sIG5lZ2F0aXZlOiBuZWdhdGl2ZSB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIldoaXRlc3BhY2VcIjpcbiAgICAgIHJldHVybiB7IHR5cGU6IFwid2lsZGNhcmRcIiwgdmFsdWU6IFt7IGZyb206IFwiXFx1MDAwOVwiLCB0bzogXCJcXHUwMDBEXCIgfSwgXCIgXCIsIFwiwoVcIiwgXCLCoFwiLCBcIuGagFwiLCB7IGZyb206IFwiXCIsIHRvOiBcIuKAjVwiIH0sIFwi4oCvXCIsIFwi4oGfXCIsIFwi44CAXCIsIFwi4aCOXCIsIFwi4oGgXCIsIFwi77u/XCJdLCBuZWdhdGl2ZTogbmVnYXRpdmUgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoL1tcXHNcXFNdLVtcXHNcXFNdLy50ZXN0KHR5cGUpKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwid2lsZGNhcmRcIiwgdmFsdWU6IFt7IGZyb206IHR5cGVbMF0sIHRvOiB0eXBlWzJdIH1dLCBuZWdhdGl2ZTogbmVnYXRpdmUgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cz1yZWdleEdyYW1tYXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./regex-rules.js\n");

/***/ }),

/***/ "./tree.js":
/*!*****************!*\
  !*** ./tree.js ***!
  \*****************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//Helper functions\n//Tree Implimentation from https://gist.github.com/RainbowDangerDash/e006151f60003487e208\nfunction Tree(data) {\n  this.data = data;\n  this.children = [];\n  this.parent = null;\n  this.length = 0;\n  this.level=0//useful for debugging how deep a node is\n}\nTree.fromJSON = function(jsonTree) {\n  var tree = JSON.parse(jsonTree),\n    finalTree = tree.map(function(a) { return new Tree(a.data) });\n  tree.forEach(function(a, i) { a.children.forEach(function(b) { finalTree[i].addChild(finalTree[b]) }) });\n  return finalTree[0];\n}\nTree.prototype.addChild = function(t) {\n  if (!(t instanceof this.constructor)) { t = new Tree(t) }\n  t.parent = this;\n  this.length = this.children.push(t);\n  t.level=this.level+1\n  return t;\n}\nTree.prototype.removeChild = function(i) {\n  var c = this.children.splice(i, 1)[0];\n  this.length = this.children.length;\n  c && (c.parent = null);\n  return c;\n}\nTree.prototype.splice=function(start,end){\n    var c = this.children.splice(start,end);\n  this.length = this.children.length;\n  return c;\n}\nTree.prototype.detachFromParent = function() {\n  var parent = this.parent;\n  if (parent) {\n    parent.removeChild(parent.children.indexOf(this));\n  }\n  return parent;\n}\nTree.prototype.popChild = function() {\n  var c = this.children.pop();\n  c.detachFromParent && c.detachFromParent();\n  return c;\n}\nTree.prototype.previousSibling=function(){\n  return this.parent&&this.parent.children[this.parent.children.indexOf(this)-1]\n}\n//Walk the tree\nTree.prototype.forEach = function(f, r, t, i) {\n  //r is how deep you want to go, 0 for unlimited.\n  //t is the level of the children you want, 0 for unlimited,\n  //if you for example only want the children and beyond, but not the value itself, then t would be 1,\n  //if you want the grandchildren and beyond but not the children, t would be 2\n  //go back i number of steps to see if there are parents\n  for (var ii = i, node = this; ii && node.parent && (t > 0 && r > 0); ii--) {\n    node = node.parent;\n    if (node == this) { //if parent node is equal to this node, then skip\n      return this\n    }\n  }\n  i = i | 0;\n  r = r | 0;\n  t = t | 0;\n  if (t-- <= 0) {\n    f(this, i);\n  }\n  if (--r) {\n    this.children.forEach(function(a) { a.forEach(f, r, t, i + 1) });\n  }\n  return this;\n}\nTree.prototype.forEachChild = function(f) {\n  return this.forEach(f, 2, 1, 0);\n};\n(function() {\n  var _find = function(f) {\n    var c = this.children;\n    if (!c) { return false }\n    for (var d, i = 0, l = c.length; i < l; i++) {\n      if (d = f.call(arguments[1], c[i], c)) {\n        return d;\n      }\n    };\n  }\n  Tree.prototype._find = _find;\n  Tree.prototype.find = function(f, r, t) {\n    r = r | 0;\n    t = t | 0\n    return ((t-- <= 0) ? (f(this) && this) : false) || ((--r) ? this._find(function(a) { return a.find(f, r, t) }) : false);\n  }\n})();\nTree.prototype.findIndex = function(f) {\n  return this.children.findIndex(f);\n}\nTree.prototype.getChild = function(i) {\n  return this.children[i];\n}\nTree.prototype.getFirstChild = function() {\n  return this.children[0];\n}\nTree.prototype.getLastChild = function() {\n  return this.children[this.children.length - 1];\n}\nTree.prototype.toJSON = function() {\n  var child = [];\n  this.forEach(function(a) { child.push(a) });\n  return JSON.stringify(child.map(function(a) {\n    return {\n      data: a.data,\n      children: a.children.map(function(b) { return child.indexOf(b) })\n    }\n  }))\n}\n\nmodule.exports = Tree;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90cmVlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vdHJlZS5qcz9hMzkyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vSGVscGVyIGZ1bmN0aW9uc1xuLy9UcmVlIEltcGxpbWVudGF0aW9uIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vUmFpbmJvd0RhbmdlckRhc2gvZTAwNjE1MWY2MDAwMzQ4N2UyMDhcbmZ1bmN0aW9uIFRyZWUoZGF0YSkge1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gW107XG4gIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLmxldmVsPTAvL3VzZWZ1bCBmb3IgZGVidWdnaW5nIGhvdyBkZWVwIGEgbm9kZSBpc1xufVxuVHJlZS5mcm9tSlNPTiA9IGZ1bmN0aW9uKGpzb25UcmVlKSB7XG4gIHZhciB0cmVlID0gSlNPTi5wYXJzZShqc29uVHJlZSksXG4gICAgZmluYWxUcmVlID0gdHJlZS5tYXAoZnVuY3Rpb24oYSkgeyByZXR1cm4gbmV3IFRyZWUoYS5kYXRhKSB9KTtcbiAgdHJlZS5mb3JFYWNoKGZ1bmN0aW9uKGEsIGkpIHsgYS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGIpIHsgZmluYWxUcmVlW2ldLmFkZENoaWxkKGZpbmFsVHJlZVtiXSkgfSkgfSk7XG4gIHJldHVybiBmaW5hbFRyZWVbMF07XG59XG5UcmVlLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uKHQpIHtcbiAgaWYgKCEodCBpbnN0YW5jZW9mIHRoaXMuY29uc3RydWN0b3IpKSB7IHQgPSBuZXcgVHJlZSh0KSB9XG4gIHQucGFyZW50ID0gdGhpcztcbiAgdGhpcy5sZW5ndGggPSB0aGlzLmNoaWxkcmVuLnB1c2godCk7XG4gIHQubGV2ZWw9dGhpcy5sZXZlbCsxXG4gIHJldHVybiB0O1xufVxuVHJlZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbihpKSB7XG4gIHZhciBjID0gdGhpcy5jaGlsZHJlbi5zcGxpY2UoaSwgMSlbMF07XG4gIHRoaXMubGVuZ3RoID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGMgJiYgKGMucGFyZW50ID0gbnVsbCk7XG4gIHJldHVybiBjO1xufVxuVHJlZS5wcm90b3R5cGUuc3BsaWNlPWZ1bmN0aW9uKHN0YXJ0LGVuZCl7XG4gICAgdmFyIGMgPSB0aGlzLmNoaWxkcmVuLnNwbGljZShzdGFydCxlbmQpO1xuICB0aGlzLmxlbmd0aCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICByZXR1cm4gYztcbn1cblRyZWUucHJvdG90eXBlLmRldGFjaEZyb21QYXJlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICBpZiAocGFyZW50KSB7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKHBhcmVudC5jaGlsZHJlbi5pbmRleE9mKHRoaXMpKTtcbiAgfVxuICByZXR1cm4gcGFyZW50O1xufVxuVHJlZS5wcm90b3R5cGUucG9wQ2hpbGQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGMgPSB0aGlzLmNoaWxkcmVuLnBvcCgpO1xuICBjLmRldGFjaEZyb21QYXJlbnQgJiYgYy5kZXRhY2hGcm9tUGFyZW50KCk7XG4gIHJldHVybiBjO1xufVxuVHJlZS5wcm90b3R5cGUucHJldmlvdXNTaWJsaW5nPWZ1bmN0aW9uKCl7XG4gIHJldHVybiB0aGlzLnBhcmVudCYmdGhpcy5wYXJlbnQuY2hpbGRyZW5bdGhpcy5wYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKS0xXVxufVxuLy9XYWxrIHRoZSB0cmVlXG5UcmVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZiwgciwgdCwgaSkge1xuICAvL3IgaXMgaG93IGRlZXAgeW91IHdhbnQgdG8gZ28sIDAgZm9yIHVubGltaXRlZC5cbiAgLy90IGlzIHRoZSBsZXZlbCBvZiB0aGUgY2hpbGRyZW4geW91IHdhbnQsIDAgZm9yIHVubGltaXRlZCxcbiAgLy9pZiB5b3UgZm9yIGV4YW1wbGUgb25seSB3YW50IHRoZSBjaGlsZHJlbiBhbmQgYmV5b25kLCBidXQgbm90IHRoZSB2YWx1ZSBpdHNlbGYsIHRoZW4gdCB3b3VsZCBiZSAxLFxuICAvL2lmIHlvdSB3YW50IHRoZSBncmFuZGNoaWxkcmVuIGFuZCBiZXlvbmQgYnV0IG5vdCB0aGUgY2hpbGRyZW4sIHQgd291bGQgYmUgMlxuICAvL2dvIGJhY2sgaSBudW1iZXIgb2Ygc3RlcHMgdG8gc2VlIGlmIHRoZXJlIGFyZSBwYXJlbnRzXG4gIGZvciAodmFyIGlpID0gaSwgbm9kZSA9IHRoaXM7IGlpICYmIG5vZGUucGFyZW50ICYmICh0ID4gMCAmJiByID4gMCk7IGlpLS0pIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUgPT0gdGhpcykgeyAvL2lmIHBhcmVudCBub2RlIGlzIGVxdWFsIHRvIHRoaXMgbm9kZSwgdGhlbiBza2lwXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfVxuICBpID0gaSB8IDA7XG4gIHIgPSByIHwgMDtcbiAgdCA9IHQgfCAwO1xuICBpZiAodC0tIDw9IDApIHtcbiAgICBmKHRoaXMsIGkpO1xuICB9XG4gIGlmICgtLXIpIHtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oYSkgeyBhLmZvckVhY2goZiwgciwgdCwgaSArIDEpIH0pO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuVHJlZS5wcm90b3R5cGUuZm9yRWFjaENoaWxkID0gZnVuY3Rpb24oZikge1xuICByZXR1cm4gdGhpcy5mb3JFYWNoKGYsIDIsIDEsIDApO1xufTtcbihmdW5jdGlvbigpIHtcbiAgdmFyIF9maW5kID0gZnVuY3Rpb24oZikge1xuICAgIHZhciBjID0gdGhpcy5jaGlsZHJlbjtcbiAgICBpZiAoIWMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBmb3IgKHZhciBkLCBpID0gMCwgbCA9IGMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoZCA9IGYuY2FsbChhcmd1bWVudHNbMV0sIGNbaV0sIGMpKSB7XG4gICAgICAgIHJldHVybiBkO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgVHJlZS5wcm90b3R5cGUuX2ZpbmQgPSBfZmluZDtcbiAgVHJlZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKGYsIHIsIHQpIHtcbiAgICByID0gciB8IDA7XG4gICAgdCA9IHQgfCAwXG4gICAgcmV0dXJuICgodC0tIDw9IDApID8gKGYodGhpcykgJiYgdGhpcykgOiBmYWxzZSkgfHwgKCgtLXIpID8gdGhpcy5fZmluZChmdW5jdGlvbihhKSB7IHJldHVybiBhLmZpbmQoZiwgciwgdCkgfSkgOiBmYWxzZSk7XG4gIH1cbn0pKCk7XG5UcmVlLnByb3RvdHlwZS5maW5kSW5kZXggPSBmdW5jdGlvbihmKSB7XG4gIHJldHVybiB0aGlzLmNoaWxkcmVuLmZpbmRJbmRleChmKTtcbn1cblRyZWUucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24oaSkge1xuICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXTtcbn1cblRyZWUucHJvdG90eXBlLmdldEZpcnN0Q2hpbGQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF07XG59XG5UcmVlLnByb3RvdHlwZS5nZXRMYXN0Q2hpbGQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbn1cblRyZWUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2hpbGQgPSBbXTtcbiAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGEpIHsgY2hpbGQucHVzaChhKSB9KTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGNoaWxkLm1hcChmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IGEuZGF0YSxcbiAgICAgIGNoaWxkcmVuOiBhLmNoaWxkcmVuLm1hcChmdW5jdGlvbihiKSB7IHJldHVybiBjaGlsZC5pbmRleE9mKGIpIH0pXG4gICAgfVxuICB9KSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmVlO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./tree.js\n");

/***/ })

/******/ });